<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: catch_amalgamated.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">catch_amalgamated.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="catch__amalgamated_8hpp_source.html">catch_amalgamated.hpp</a>&quot;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;stack&gt;</code><br />
<code>#include &lt;exception&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;cctype&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;cerrno&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;cstdio&gt;</code><br />
<code>#include &lt;iosfwd&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;ctime&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;regex&gt;</code><br />
<code>#include &lt;cfloat&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for catch_amalgamated.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="catch__amalgamated_8cpp__incl.png" border="0" usemap="#acatch__amalgamated_8cpp" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCatch_1_1Generators_1_1RandomFloatingGenerator_1_1PImpl.html">Catch::Generators::RandomFloatingGenerator::PImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCatch_1_1SignalDefs.html">Catch::SignalDefs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCatch_1_1ReporterRegistry_1_1ReporterRegistryImpl.html">Catch::ReporterRegistry::ReporterRegistryImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCatch_1_1StringStreams.html">Catch::StringStreams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a49ffcf43841dcedc78c808b8e62e4f12" id="r_a49ffcf43841dcedc78c808b8e62e4f12"><td class="memItemLeft" align="right" valign="top"><a id="a49ffcf43841dcedc78c808b8e62e4f12" name="a49ffcf43841dcedc78c808b8e62e4f12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Digits</b>(x)&#160;&#160;&#160;( x &amp; 0xFF'FF'FF'FF )            std::uint64_t lhs_low = Digits( lhs );            std::uint64_t rhs_low = Digits( rhs );            std::uint64_t low_low = ( lhs_low * rhs_low );            std::uint64_t high_high = CarryBits( lhs ) * CarryBits( rhs );                        std::uint64_t high_low =                ( CarryBits( lhs ) * rhs_low ) + CarryBits( low_low );                                    std::uint64_t low_high =                ( lhs_low * CarryBits( rhs ) ) + Digits( high_low );            return { high_high + CarryBits( high_low ) + CarryBits( low_high ),                     ( low_high &lt;&lt; 32 ) | Digits( low_low ) };#undef CarryBits#undef Digits        }                inline ExtendedMultResult&lt;std::uint64_t&gt;        extendedMult( std::uint64_t lhs, std::uint64_t rhs ) {#if defined( CATCH_CONFIG_UINT128 )            auto result = __uint128_t( lhs ) * __uint128_t( rhs );            return { static_cast&lt;std::uint64_t&gt;( result &gt;&gt; 64 ),                     static_cast&lt;std::uint64_t&gt;( result ) };#elif defined( CATCH_CONFIG_MSVC_UMUL128 )            std::uint64_t high;            std::uint64_t low = _umul128( lhs, rhs, &amp;high );            return { high, low };#else            return extendedMultPortable( lhs, rhs );#endif        }        template &lt;typename UInt&gt;        constexpr ExtendedMultResult&lt;UInt&gt; extendedMult( UInt lhs, UInt rhs ) {            static_assert( std::is_unsigned&lt;UInt&gt;::value,                           &quot;extendedMult can only handle unsigned integers&quot; );            static_assert( sizeof( UInt ) &lt; sizeof( std::uint64_t ),                           &quot;Generic extendedMult can only handle types smaller &quot;                           &quot;than uint64_t&quot; );            using WideType = DoubleWidthUnsignedType_t&lt;UInt&gt;;            auto result = WideType( lhs ) * WideType( rhs );            return {                static_cast&lt;UInt&gt;( result &gt;&gt; ( CHAR_BIT * sizeof( UInt ) ) ),                static_cast&lt;UInt&gt;( result &amp; UInt( -1 ) ) };        }        template &lt;typename TargetType,                  typename Generator&gt;            std::enable_if_t&lt;sizeof(typename Generator::result_type) &gt;= sizeof(TargetType),            TargetType&gt; fillBitsFrom(Generator&amp; gen) {            using gresult_type = typename Generator::result_type;            static_assert( std::is_unsigned&lt;TargetType&gt;::value, &quot;Only unsigned integers are supported&quot; );            static_assert( Generator::min() == 0 &amp;&amp;                           Generator::max() == static_cast&lt;gresult_type&gt;( -1 ),                           &quot;Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)&quot; );                                    constexpr auto generated_bits = sizeof( gresult_type ) * CHAR_BIT;            constexpr auto return_bits = sizeof( TargetType ) * CHAR_BIT;            return static_cast&lt;TargetType&gt;( gen() &gt;&gt;                                            ( generated_bits - return_bits) );        }        template &lt;typename TargetType,                  typename Generator&gt;            std::enable_if_t&lt;sizeof(typename Generator::result_type) &lt; sizeof(TargetType),            TargetType&gt; fillBitsFrom(Generator&amp; gen) {            using gresult_type = typename Generator::result_type;            static_assert( std::is_unsigned&lt;TargetType&gt;::value,                           &quot;Only unsigned integers are supported&quot; );            static_assert( Generator::min() == 0 &amp;&amp;                           Generator::max() == static_cast&lt;gresult_type&gt;( -1 ),                           &quot;Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)&quot; );            constexpr auto generated_bits = sizeof( gresult_type ) * CHAR_BIT;            constexpr auto return_bits = sizeof( TargetType ) * CHAR_BIT;            std::size_t filled_bits = 0;            TargetType ret = 0;            do {                ret &lt;&lt;= generated_bits;                ret |= gen();                filled_bits += generated_bits;            } while ( filled_bits &lt; return_bits );            return ret;        }                template &lt;typename OriginalType, typename UnsignedType&gt;        constexpr        std::enable_if_t&lt;std::is_signed&lt;OriginalType&gt;::value, UnsignedType&gt;        transposeToNaturalOrder( UnsignedType in ) {            static_assert(                sizeof( OriginalType ) == sizeof( UnsignedType ),                &quot;reordering requires the same sized types on both sides&quot; );            static_assert( std::is_unsigned&lt;UnsignedType&gt;::value,                           &quot;Input type must be unsigned&quot; );                                                            constexpr auto highest_bit =                UnsignedType( 1 ) &lt;&lt; ( sizeof( UnsignedType ) * CHAR_BIT - 1 );            return static_cast&lt;UnsignedType&gt;( in ^ highest_bit );        }        template &lt;typename OriginalType,                  typename UnsignedType&gt;        constexpr        std::enable_if_t&lt;std::is_unsigned&lt;OriginalType&gt;::value, UnsignedType&gt;            transposeToNaturalOrder(UnsignedType in) {            static_assert(                sizeof( OriginalType ) == sizeof( UnsignedType ),                &quot;reordering requires the same sized types on both sides&quot; );            static_assert( std::is_unsigned&lt;UnsignedType&gt;::value, &quot;Input type must be unsigned&quot; );                        return in;        }    } } #endif namespace Catch {template &lt;typename IntegerType&gt;class uniform_integer_distribution {    static_assert(std::is_integral&lt;IntegerType&gt;::value, &quot;...&quot;);    using UnsignedIntegerType = Detail::SizedUnsignedType_t&lt;sizeof(IntegerType)&gt;;                        UnsignedIntegerType m_a;        UnsignedIntegerType m_ab_distance;                            UnsignedIntegerType m_rejection_threshold = 0;    static constexpr UnsignedIntegerType computeDistance(IntegerType a, IntegerType b) {                        return transposeTo(b) - transposeTo(a) + 1;    }    static constexpr UnsignedIntegerType computeRejectionThreshold(UnsignedIntegerType ab_distance) {                        if ( ab_distance == 0 ) { return 0; }        return ( ~ab_distance + 1 ) % ab_distance;    }    static constexpr UnsignedIntegerType transposeTo(IntegerType in) {        return Detail::transposeToNaturalOrder&lt;IntegerType&gt;(            static_cast&lt;UnsignedIntegerType&gt;( in ) );    }    static constexpr IntegerType transposeBack(UnsignedIntegerType in) {        return static_cast&lt;IntegerType&gt;(            Detail::transposeToNaturalOrder&lt;IntegerType&gt;(in) );    }public:    using result_type = IntegerType;    constexpr uniform_integer_distribution( IntegerType a, IntegerType b ):        m_a( transposeTo(a) ),        m_ab_distance( computeDistance(a, b) ),        m_rejection_threshold( computeRejectionThreshold(m_ab_distance) ) {        assert( a &lt;= b );    }    template &lt;typename Generator&gt;    constexpr result_type operator()( Generator&amp; g ) {                if ( m_ab_distance == 0 ) {            return transposeBack( Detail::fillBitsFrom&lt;UnsignedIntegerType&gt;( g ) );        }        auto random_number = Detail::fillBitsFrom&lt;UnsignedIntegerType&gt;( g );        auto emul = Detail::extendedMult( random_number, m_ab_distance );                        while (emul.lower &lt; m_rejection_threshold) {            random_number = Detail::fillBitsFrom&lt;UnsignedIntegerType&gt;( g );            emul = Detail::extendedMult( random_number, m_ab_distance );        }        return transposeBack(m_a + emul.upper);    }    constexpr result_type a() const { return transposeBack(m_a); }    constexpr result_type b() const { return transposeBack(m_ab_distance + m_a - 1); }};} #endif #ifndef CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED#define CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED#ifndef CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED#define CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED#ifndef CATCH_POLYFILLS_HPP_INCLUDED#define CATCH_POLYFILLS_HPP_INCLUDEDnamespace Catch {    bool isnan(float f);    bool isnan(double d);    float nextafter(float x, float y);    double nextafter(double x, double y);}#endif #include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdint&gt;#include &lt;limits&gt;#include &lt;type_traits&gt;namespace Catch {    namespace Detail {                template &lt;typename FloatType&gt;        FloatType gamma(FloatType a, FloatType b) {            static_assert( std::is_floating_point&lt;FloatType&gt;::value,                           &quot;gamma returns the largest ULP magnitude within &quot;                           &quot;floating point range [a, b]. This only makes sense &quot;                           &quot;for floating point types&quot; );            assert( a &lt;= b );            const auto gamma_up = Catch::nextafter( a, std::numeric_limits&lt;FloatType&gt;::infinity() ) - a;            const auto gamma_down = b - Catch::nextafter( b, -std::numeric_limits&lt;FloatType&gt;::infinity() );            return gamma_up &lt; gamma_down ? gamma_down : gamma_up;        }        template &lt;typename FloatingPoint&gt;        struct DistanceTypePicker;        template &lt;&gt;        struct DistanceTypePicker&lt;float&gt; {            using type = std::uint32_t;        };        template &lt;&gt;        struct DistanceTypePicker&lt;double&gt; {            using type = std::uint64_t;        };        template &lt;typename T&gt;        using DistanceType = typename DistanceTypePicker&lt;T&gt;::type;#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic push#    pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;#endif                template &lt;typename FloatType&gt;        DistanceType&lt;FloatType&gt;        count_equidistant_floats( FloatType a, FloatType b, FloatType distance ) {            assert( a &lt;= b );                                    const auto ag = a / distance;            const auto bg = b / distance;            const auto s = bg - ag;            const auto err = ( std::fabs( a ) &lt;= std::fabs( b ) )                                 ? -ag - ( s - bg )                                 : bg - ( s + ag );            const auto ceil_s = static_cast&lt;DistanceType&lt;FloatType&gt;&gt;( std::ceil( s ) );            return ( ceil_s != s ) ? ceil_s : ceil_s + ( err &gt; 0 );        }#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif    }} #endif #include &lt;cmath&gt;#include &lt;type_traits&gt;namespace Catch {    namespace Detail {#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic push#    pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;#endif                                        constexpr std::uint64_t calculate_max_steps_in_one_go(double gamma) {            if ( gamma == 1.99584030953472e+292 ) { return 9007199254740991; }            return static_cast&lt;std::uint64_t&gt;( -1 );        }        constexpr std::uint32_t calculate_max_steps_in_one_go(float gamma) {            if ( gamma == 2.028241e+31f ) { return 16777215; }            return static_cast&lt;std::uint32_t&gt;( -1 );        }#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif    }template &lt;typename FloatType&gt;class uniform_floating_point_distribution {    static_assert(std::is_floating_point&lt;FloatType&gt;::value, &quot;...&quot;);    static_assert(!std::is_same&lt;FloatType, long double&gt;::value,                  &quot;We do not support long double due to inconsistent behaviour between platforms&quot;);    using WidthType = Detail::DistanceType&lt;FloatType&gt;;    FloatType m_a, m_b;    FloatType m_ulp_magnitude;    WidthType m_floats_in_range;    uniform_integer_distribution&lt;WidthType&gt; m_int_dist;                WidthType m_max_steps_in_one_go;        bool m_a_has_leq_magnitude;public:    using result_type = FloatType;    uniform_floating_point_distribution( FloatType a, FloatType b ):        m_a( a ),        m_b( b ),        m_ulp_magnitude( Detail::gamma( m_a, m_b ) ),        m_floats_in_range( Detail::count_equidistant_floats( m_a, m_b, m_ulp_magnitude ) ),        m_int_dist(0, m_floats_in_range),        m_max_steps_in_one_go( Detail::calculate_max_steps_in_one_go(m_ulp_magnitude)),        m_a_has_leq_magnitude(std::fabs(m_a) &lt;= std::fabs(m_b))    {        assert( a &lt;= b );    }    template &lt;typename Generator&gt;    result_type operator()( Generator&amp; g ) {        WidthType steps = m_int_dist( g );        if ( m_a_has_leq_magnitude ) {            if ( steps == m_floats_in_range ) { return m_a; }            auto b = m_b;            while (steps &gt; m_max_steps_in_one_go) {                b -= m_max_steps_in_one_go * m_ulp_magnitude;                steps -= m_max_steps_in_one_go;            }            return b - steps * m_ulp_magnitude;        } else {            if ( steps == m_floats_in_range ) { return m_b; }            auto a = m_a;            while (steps &gt; m_max_steps_in_one_go) {                a += m_max_steps_in_one_go * m_ulp_magnitude;                steps -= m_max_steps_in_one_go;            }            return a + steps * m_ulp_magnitude;        }    }    result_type a() const { return m_a; }    result_type b() const { return m_b; }};} #endif namespace Catch {namespace Generators {namespace Detail {                std::uint32_t getSeed();}template &lt;typename Float&gt;class RandomFloatingGenerator final : public IGenerator&lt;Float&gt; {    <a class="el" href="classCatch_1_1SimplePcg32.html">Catch::SimplePcg32</a> m_rng;    Catch::uniform_floating_point_distribution&lt;Float&gt; m_dist;    Float m_current_number;public:    RandomFloatingGenerator( Float a, Float b, std::uint32_t seed ):        m_rng(seed),        m_dist(a, b) {        static_cast&lt;void&gt;(next());    }    Float const&amp; get() const override {        return m_current_number;    }    bool next() override {        m_current_number = m_dist(m_rng);        return true;    }};template &lt;&gt;class RandomFloatingGenerator&lt;long double&gt; final : public IGenerator&lt;long double&gt; {            struct PImpl;    <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Catch::Detail::unique_ptr</a>&lt;PImpl&gt; m_pimpl;    long double m_current_number;public:    RandomFloatingGenerator( long double a, long double b, std::uint32_t seed );    long double const&amp; get() const override { return m_current_number; }    bool next() override;    ~RandomFloatingGenerator() override; };template &lt;typename Integer&gt;class RandomIntegerGenerator final : public IGenerator&lt;Integer&gt; {    <a class="el" href="classCatch_1_1SimplePcg32.html">Catch::SimplePcg32</a> m_rng;    Catch::uniform_integer_distribution&lt;Integer&gt; m_dist;    Integer m_current_number;public:    RandomIntegerGenerator( Integer a, Integer b, std::uint32_t seed ):        m_rng(seed),        m_dist(a, b) {        static_cast&lt;void&gt;(next());    }    Integer const&amp; get() const override {        return m_current_number;    }    bool next() override {        m_current_number = m_dist(m_rng);        return true;    }};template &lt;typename T&gt;std::enable_if_t&lt;std::is_integral&lt;T&gt;::value, GeneratorWrapper&lt;T&gt;&gt;random(T a, T b) {    return GeneratorWrapper&lt;T&gt;(        Catch::Detail::make_unique&lt;RandomIntegerGenerator&lt;T&gt;&gt;(a, b, Detail::getSeed())    );}template &lt;typename T&gt;std::enable_if_t&lt;std::is_floating_point&lt;T&gt;::value,GeneratorWrapper&lt;T&gt;&gt;random(T a, T b) {    return GeneratorWrapper&lt;T&gt;(        Catch::Detail::make_unique&lt;RandomFloatingGenerator&lt;T&gt;&gt;(a, b, Detail::getSeed())    );}} } #endif #ifndef CATCH_GENERATORS_RANGE_HPP_INCLUDED#define CATCH_GENERATORS_RANGE_HPP_INCLUDED#include &lt;iterator&gt;#include &lt;type_traits&gt;namespace Catch {namespace Generators {template &lt;typename T&gt;class RangeGenerator final : public IGenerator&lt;T&gt; {    T m_current;    T m_end;    T m_step;    bool m_positive;public:    RangeGenerator(T const&amp; start, T const&amp; end, T const&amp; step):        m_current(start),        m_end(end),        m_step(step),        m_positive(m_step &gt; T(0))    {        assert(m_current != m_end &amp;&amp; &quot;Range start and end cannot be equal&quot;);        assert(m_step != T(0) &amp;&amp; &quot;Step size cannot be zero&quot;);        assert(((m_positive &amp;&amp; m_current &lt;= m_end) || (!m_positive &amp;&amp; m_current &gt;= m_end)) &amp;&amp; &quot;Step moves away from end&quot;);    }    RangeGenerator(T const&amp; start, T const&amp; end):        RangeGenerator(start, end, (start &lt; end) ? T(1) : T(-1))    {}    T const&amp; get() const override {        return m_current;    }    bool next() override {        m_current += m_step;        return (m_positive) ? (m_current &lt; m_end) : (m_current &gt; m_end);    }};template &lt;typename T&gt;GeneratorWrapper&lt;T&gt; range(T const&amp; start, T const&amp; end, T const&amp; step) {    static_assert(std::is_arithmetic&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, &quot;Type must be numeric&quot;);    return GeneratorWrapper&lt;T&gt;(Catch::Detail::make_unique&lt;RangeGenerator&lt;T&gt;&gt;(start, end, step));}template &lt;typename T&gt;GeneratorWrapper&lt;T&gt; range(T const&amp; start, T const&amp; end) {    static_assert(std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, &quot;Type must be an integer&quot;);    return GeneratorWrapper&lt;T&gt;(Catch::Detail::make_unique&lt;RangeGenerator&lt;T&gt;&gt;(start, end));}template &lt;typename T&gt;class IteratorGenerator final : public IGenerator&lt;T&gt; {    static_assert(!std::is_same&lt;T, bool&gt;::value,        &quot;IteratorGenerator currently does not support bools&quot;        &quot;because of std::vector&lt;bool&gt; specialization&quot;);    std::vector&lt;T&gt; m_elems;    size_t m_current = 0;public:    template &lt;typename InputIterator, typename InputSentinel&gt;    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {        if (m_elems.empty()) {            Detail::throw_generator_exception(&quot;IteratorGenerator received no valid values&quot;);        }    }    T const&amp; get() const override {        return m_elems[m_current];    }    bool next() override {        ++m_current;        return m_current != m_elems.size();    }};template &lt;typename InputIterator,          typename InputSentinel,          typename ResultType = std::remove_const_t&lt;typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;&gt;GeneratorWrapper&lt;ResultType&gt; from_range(InputIterator from, InputSentinel to) {    return GeneratorWrapper&lt;ResultType&gt;(Catch::Detail::make_unique&lt;IteratorGenerator&lt;ResultType&gt;&gt;(from, to));}template &lt;typename Container&gt;auto from_range(Container const&amp; cnt) {    using std::begin;    using std::end;    return from_range( begin( cnt ), end( cnt ) );}} } #endif #endif #ifndef CATCH_INTERFACES_ALL_HPP_INCLUDED#define CATCH_INTERFACES_ALL_HPP_INCLUDED#ifndef CATCH_INTERFACES_REPORTER_HPP_INCLUDED#define CATCH_INTERFACES_REPORTER_HPP_INCLUDED#include &lt;map&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace Catch {    struct ReporterDescription;    struct ListenerDescription;    struct TagInfo;    struct TestCaseInfo;    class TestCaseHandle;    class IConfig;    class IStream;    enum class ColourMode : std::uint8_t;    struct ReporterConfig {        ReporterConfig( IConfig const* _fullConfig,                        Detail::unique_ptr&lt;IStream&gt; _stream,                        ColourMode colourMode,                        std::map&lt;std::string, std::string&gt; customOptions );        ReporterConfig( ReporterConfig&amp;&amp; ) = default;        ReporterConfig&amp; operator=( ReporterConfig&amp;&amp; ) = default;        ~ReporterConfig();         Detail::unique_ptr&lt;IStream&gt; takeStream() &amp;&amp;;        IConfig const* fullConfig() const;        ColourMode colourMode() const;        std::map&lt;std::string, std::string&gt; const&amp; customOptions() const;    private:        Detail::unique_ptr&lt;IStream&gt; m_stream;        IConfig const* m_fullConfig;        ColourMode m_colourMode;        std::map&lt;std::string, std::string&gt; m_customOptions;    };    struct AssertionStats {        AssertionStats( AssertionResult const&amp; _assertionResult,                        std::vector&lt;MessageInfo&gt; const&amp; _infoMessages,                        Totals const&amp; _totals );        AssertionStats( AssertionStats const&amp; )              = default;        AssertionStats( AssertionStats &amp;&amp; )                  = default;        AssertionStats&amp; operator = ( AssertionStats const&amp; ) = delete;        AssertionStats&amp; operator = ( AssertionStats &amp;&amp; )     = delete;        AssertionResult assertionResult;        std::vector&lt;MessageInfo&gt; infoMessages;        Totals totals;    };    struct SectionStats {        SectionStats(   SectionInfo&amp;&amp; _sectionInfo,                        Counts const&amp; _assertions,                        double _durationInSeconds,                        bool _missingAssertions );        SectionInfo sectionInfo;        Counts assertions;        double durationInSeconds;        bool missingAssertions;    };    struct TestCaseStats {        TestCaseStats(  TestCaseInfo const&amp; _testInfo,                        Totals const&amp; _totals,                        std::string&amp;&amp; _stdOut,                        std::string&amp;&amp; _stdErr,                        bool _aborting );        TestCaseInfo const * testInfo;        Totals totals;        std::string stdOut;        std::string stdErr;        bool aborting;    };    struct TestRunStats {        TestRunStats(   TestRunInfo const&amp; _runInfo,                        Totals const&amp; _totals,                        bool _aborting );        TestRunInfo runInfo;        Totals totals;        bool aborting;    };                struct ReporterPreferences {                        bool shouldRedirectStdOut = false;                        bool shouldReportAllAssertions = false;                                        bool shouldReportAllAssertionStarts = true;    };        class IEventListener {    protected:                ReporterPreferences m_preferences;                IConfig const* m_config;    public:        IEventListener( IConfig const* config ): m_config( config ) {}        virtual ~IEventListener();                         ReporterPreferences const&amp; getPreferences() const {            return m_preferences;        }                virtual void noMatchingTestCases( StringRef unmatchedSpec ) = 0;                virtual void reportInvalidTestSpec( StringRef invalidArgument ) = 0;                virtual void testRunStarting( TestRunInfo const&amp; testRunInfo ) = 0;                virtual void testCaseStarting( TestCaseInfo const&amp; testInfo ) = 0;                virtual void testCasePartialStarting( TestCaseInfo const&amp; testInfo, uint64_t partNumber ) = 0;                virtual void sectionStarting( SectionInfo const&amp; sectionInfo ) = 0;                virtual void benchmarkPreparing( StringRef benchmarkName ) = 0;                virtual void benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) = 0;                virtual void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) = 0;                virtual void benchmarkFailed( StringRef benchmarkName ) = 0;                virtual void assertionStarting( AssertionInfo const&amp; assertionInfo ) = 0;                virtual void assertionEnded( AssertionStats const&amp; assertionStats ) = 0;                virtual void sectionEnded( SectionStats const&amp; sectionStats ) = 0;                virtual void testCasePartialEnded(TestCaseStats const&amp; testCaseStats, uint64_t partNumber ) = 0;                virtual void testCaseEnded( TestCaseStats const&amp; testCaseStats ) = 0;                virtual void testRunEnded( TestRunStats const&amp; testRunStats ) = 0;                virtual void skipTest( TestCaseInfo const&amp; testInfo ) = 0;                virtual void fatalErrorEncountered( StringRef error ) = 0;                virtual void listReporters(std::vector&lt;ReporterDescription&gt; const&amp; descriptions) = 0;                virtual void listListeners(std::vector&lt;ListenerDescription&gt; const&amp; descriptions) = 0;                virtual void listTests(std::vector&lt;TestCaseHandle&gt; const&amp; tests) = 0;                virtual void listTags(std::vector&lt;TagInfo&gt; const&amp; tags) = 0;    };    using IEventListenerPtr = Detail::unique_ptr&lt;IEventListener&gt;;} #endif #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED#define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED#include &lt;string&gt;namespace Catch {    struct ReporterConfig;    class IConfig;    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr&lt;IEventListener&gt;;    class IReporterFactory {    public:        virtual ~IReporterFactory();         virtual IEventListenerPtr        create( ReporterConfig&amp;&amp; config ) const = 0;        virtual std::string getDescription() const = 0;    };    using IReporterFactoryPtr = Detail::unique_ptr&lt;IReporterFactory&gt;;    class EventListenerFactory {    public:        virtual ~EventListenerFactory();         virtual IEventListenerPtr create( IConfig const* config ) const = 0;                virtual StringRef getName() const = 0;                virtual std::string getDescription() const = 0;    };} #endif #ifndef CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED#define CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED#include &lt;string&gt;namespace Catch {    struct TagAlias;    class ITagAliasRegistry {    public:        virtual ~ITagAliasRegistry();                 virtual TagAlias const* find( std::string const&amp; alias ) const = 0;        virtual std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const = 0;        static ITagAliasRegistry const&amp; get();    };} #endif #ifndef CATCH_INTERFACES_TESTCASE_HPP_INCLUDED#define CATCH_INTERFACES_TESTCASE_HPP_INCLUDED#include &lt;vector&gt;namespace Catch {    struct TestCaseInfo;    class TestCaseHandle;    class IConfig;    class ITestCaseRegistry {    public:        virtual ~ITestCaseRegistry();                 virtual std::vector&lt;TestCaseInfo* &gt; const&amp; getAllInfos() const = 0;        virtual std::vector&lt;TestCaseHandle&gt; const&amp; getAllTests() const = 0;        virtual std::vector&lt;TestCaseHandle&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const = 0;    };}#endif #endif #ifndef CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED#define CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDEDnamespace Catch {    namespace Detail {                struct CaseInsensitiveLess {            bool operator()( StringRef lhs,                             StringRef rhs ) const;        };                struct CaseInsensitiveEqualTo {            bool operator()( StringRef lhs,                             StringRef rhs ) const;        };    } } #endif #ifndef CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED#define CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED#if defined(__ANDROID__)#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE#endif#if defined( CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE ) &amp;&amp; \    !defined( CATCH_CONFIG_NO_ANDROID_LOGWRITE ) &amp;&amp;      \    !defined( CATCH_CONFIG_ANDROID_LOGWRITE )#    define CATCH_CONFIG_ANDROID_LOGWRITE#endif#endif #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#if defined(_MSC_VER)#  if _MSC_VER &gt;= 1900 #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#  endif#endif#include &lt;exception&gt;#if defined(__cpp_lib_uncaught_exceptions) \    &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#endif #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \    &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \    &amp;&amp; !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#endif#endif #ifndef CATCH_CONSOLE_COLOUR_HPP_INCLUDED#define CATCH_CONSOLE_COLOUR_HPP_INCLUDED#include &lt;iosfwd&gt;#include &lt;cstdint&gt;namespace Catch {    enum class ColourMode : std::uint8_t;    class IStream;    struct Colour {        enum Code {            None = 0,            White,            Red,            Green,            Blue,            Cyan,            Yellow,            Grey,            Bright = 0x10,            BrightRed = Bright | Red,            BrightGreen = Bright | Green,            LightGrey = Bright | Grey,            BrightWhite = Bright | White,            BrightYellow = Bright | Yellow,                        FileName = LightGrey,            Warning = BrightYellow,            ResultError = BrightRed,            ResultSuccess = BrightGreen,            ResultExpectedFailure = Warning,            Error = BrightRed,            Success = Green,            Skip = LightGrey,            OriginalExpression = Cyan,            ReconstructedExpression = BrightYellow,            SecondaryText = LightGrey,            Headers = White        };    };    class ColourImpl {    protected:                IStream* m_stream;    public:        ColourImpl( IStream* stream ): m_stream( stream ) {}                        class ColourGuard {            ColourImpl const* m_colourImpl;            Colour::Code m_code;            bool m_engaged = false;        public:                        ColourGuard( Colour::Code code,                         ColourImpl const* colour );            ColourGuard( ColourGuard const&amp; rhs ) = delete;            ColourGuard&amp; operator=( ColourGuard const&amp; rhs ) = delete;            ColourGuard( ColourGuard&amp;&amp; rhs ) noexcept;            ColourGuard&amp; operator=( ColourGuard&amp;&amp; rhs ) noexcept;                        ~ColourGuard();                        ColourGuard&amp; engage( std::ostream&amp; stream ) &amp;;                        ColourGuard&amp;&amp; engage( std::ostream&amp; stream ) &amp;&amp;;        private:                        friend std::ostream&amp; operator&lt;&lt;( std::ostream&amp; lhs,                                             ColourGuard&amp; guard ) {                guard.engageImpl( lhs );                return lhs;            }                        friend std::ostream&amp; operator&lt;&lt;( std::ostream&amp; lhs,                                            ColourGuard&amp;&amp; guard) {                guard.engageImpl( lhs );                return lhs;            }            void engageImpl( std::ostream&amp; stream );        };        virtual ~ColourImpl();                 ColourGuard guardColour( Colour::Code colourCode );    private:        virtual void use( Colour::Code colourCode ) const = 0;    };        Detail::unique_ptr&lt;ColourImpl&gt; makeColourImpl( ColourMode colourSelection,                                                   IStream* stream );        bool isColourImplAvailable( ColourMode colourSelection );} #endif #ifndef CATCH_CONSOLE_WIDTH_HPP_INCLUDED#define CATCH_CONSOLE_WIDTH_HPP_INCLUDED#ifndef CATCH_CONFIG_CONSOLE_WIDTH#define CATCH_CONFIG_CONSOLE_WIDTH 80#endif#endif #ifndef CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED#define CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED#include &lt;cstddef&gt;#include &lt;initializer_list&gt;#if defined(CATCH_CPP17_OR_GREATER) || defined(_MSC_VER)#include &lt;string&gt;#  if !defined(__cpp_lib_nonmember_container_access)#      define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS#  endif#else#define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS#endifnamespace Catch {namespace Detail {#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)    template &lt;typename Container&gt;    constexpr auto empty(Container const&amp; cont) -&gt; decltype(cont.empty()) {        return cont.empty();    }    template &lt;typename T, std::size_t N&gt;    constexpr bool empty(const T (&amp;)[N]) noexcept {                        (void)N;        return false;    }    template &lt;typename T&gt;    constexpr bool empty(std::initializer_list&lt;T&gt; list) noexcept {        return list.size() &gt; 0;    }    template &lt;typename Container&gt;    constexpr auto size(Container const&amp; cont) -&gt; decltype(cont.size()) {        return cont.size();    }    template &lt;typename T, std::size_t N&gt;    constexpr std::size_t size(const T(&amp;)[N]) noexcept {        return N;    }#endif } } #endif #ifndef CATCH_DEBUG_CONSOLE_HPP_INCLUDED#define CATCH_DEBUG_CONSOLE_HPP_INCLUDED#include &lt;string&gt;namespace Catch {    void writeToDebugConsole( std::string const&amp; text );}#endif #ifndef CATCH_DEBUGGER_HPP_INCLUDED#define CATCH_DEBUGGER_HPP_INCLUDEDnamespace Catch {    bool isDebuggerActive();}#if !defined( CATCH_TRAP ) &amp;&amp; defined( __clang__ ) &amp;&amp; defined( __has_builtin )#    if __has_builtin( __builtin_debugtrap )#        define CATCH_TRAP() __builtin_debugtrap()#    endif#endif#if !defined( CATCH_TRAP ) &amp;&amp; defined( _MSC_VER )#    define CATCH_TRAP() __debugbreak()#endif#if !defined(CATCH_TRAP) #ifdef CATCH_PLATFORM_MAC    #if defined(__i386__) || defined(__x86_64__)        #define CATCH_TRAP() __asm__(&quot;int $3\n&quot; : : )     #elif defined(__aarch64__)        #define CATCH_TRAP() __asm__(&quot;.inst 0xd43e0000&quot;)    #elif defined(__POWERPC__)        #define CATCH_TRAP() __asm__(&quot;li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n&quot; \        : : : &quot;memory&quot;,&quot;r0&quot;,&quot;r3&quot;,&quot;r4&quot; )     #endif#elif defined(CATCH_PLATFORM_IPHONE)        #if defined(__i386__) || defined(__x86_64__)        #define CATCH_TRAP()  __asm__(&quot;int $3&quot;)    #elif defined(__aarch64__)        #define CATCH_TRAP()  __asm__(&quot;.inst 0xd4200000&quot;)    #elif defined(__arm__) &amp;&amp; !defined(__thumb__)        #define CATCH_TRAP()  __asm__(&quot;.inst 0xe7f001f0&quot;)    #elif defined(__arm__) &amp;&amp;  defined(__thumb__)        #define CATCH_TRAP()  __asm__(&quot;.inst 0xde01&quot;)    #endif#elif defined(CATCH_PLATFORM_LINUX)                #if defined(__GNUC__) &amp;&amp; (defined(__i386) || defined(__x86_64))        #define CATCH_TRAP() asm volatile (&quot;int $3&quot;)     #else         #include &lt;signal.h&gt;        #define CATCH_TRAP() raise(SIGTRAP)    #endif#elif defined(__MINGW32__)    extern &quot;C&quot; __declspec(dllimport) void __stdcall DebugBreak();    #define CATCH_TRAP() DebugBreak()#endif#endif #if !defined(CATCH_BREAK_INTO_DEBUGGER)    #if defined(CATCH_TRAP)        #define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()    #else        #define CATCH_BREAK_INTO_DEBUGGER() []{}()    #endif#endif#endif #ifndef CATCH_ENFORCE_HPP_INCLUDED#define CATCH_ENFORCE_HPP_INCLUDED#include &lt;exception&gt; namespace Catch {#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)    template &lt;typename Ex&gt;    [[noreturn]]    void throw_exception(Ex const&amp; e) {        throw e;    }#else     [[noreturn]]    void throw_exception(std::exception const&amp; e);#endif    [[noreturn]]    void throw_logic_error(std::string const&amp; msg);    [[noreturn]]    void throw_domain_error(std::string const&amp; msg);    [[noreturn]]    void throw_runtime_error(std::string const&amp; msg);} #define CATCH_MAKE_MSG(...) \    (Catch::ReusableStringStream() &lt;&lt; __VA_ARGS__).str()#define CATCH_INTERNAL_ERROR(...) \    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO &lt;&lt; &quot;: Internal Catch2 error: &quot; &lt;&lt; __VA_ARGS__))#define CATCH_ERROR(...) \    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))#define CATCH_RUNTIME_ERROR(...) \    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))#define CATCH_ENFORCE( condition, ... ) \    do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)#endif #ifndef CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED#define CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED#include &lt;vector&gt;namespace Catch {    namespace Detail {        <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Catch::Detail::unique_ptr</a>&lt;EnumInfo&gt; makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values );        class EnumValuesRegistry : public IMutableEnumValuesRegistry {            std::vector&lt;<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Catch::Detail::unique_ptr</a>&lt;EnumInfo&gt;&gt; m_enumInfos;            EnumInfo const&amp; registerEnum( StringRef enumName, StringRef allValueNames, std::vector&lt;int&gt; const&amp; values) override;        };        std::vector&lt;StringRef&gt; parseEnums( StringRef enums );    } } #endif #ifndef CATCH_ERRNO_GUARD_HPP_INCLUDED#define CATCH_ERRNO_GUARD_HPP_INCLUDEDnamespace Catch {            class ErrnoGuard {    public:                ErrnoGuard();        ~ErrnoGuard();    private:        int m_oldErrno;    };}#endif #ifndef CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED#define CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED#include &lt;string&gt;namespace Catch {    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {    public:        ~ExceptionTranslatorRegistry() override;        void registerTranslator( Detail::unique_ptr&lt;IExceptionTranslator&gt;&amp;&amp; translator );        std::string translateActiveException() const override;    private:        ExceptionTranslators m_translators;    };}#endif #ifndef CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED#define CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED#include &lt;cassert&gt;namespace Catch {        class FatalConditionHandler {        bool m_started = false;                                void engage_platform();        void disengage_platform() noexcept;    public:                FatalConditionHandler();        ~FatalConditionHandler();        void engage() {            assert(!m_started &amp;&amp; &quot;Handler cannot be installed twice.&quot;);            m_started = true;            engage_platform();        }        void disengage() noexcept {            assert(m_started &amp;&amp; &quot;Handler cannot be uninstalled without being installed first&quot;);            m_started = false;            disengage_platform();        }    };        class FatalConditionHandlerGuard {        FatalConditionHandler* m_handler;    public:        FatalConditionHandlerGuard(FatalConditionHandler* handler):            m_handler(handler) {            m_handler-&gt;engage();        }        ~FatalConditionHandlerGuard() {            m_handler-&gt;disengage();        }    };} #endif #ifndef CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED#define CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdint&gt;#include &lt;utility&gt;#include &lt;limits&gt;namespace Catch {    namespace Detail {        uint32_t convertToBits(float f);        uint64_t convertToBits(double d);                        bool directCompare( float lhs, float rhs );        bool directCompare( double lhs, double rhs );    } #if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic push            #    pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;#endif        template &lt;typename FP&gt;    uint64_t ulpDistance( FP lhs, FP rhs ) {        assert( std::numeric_limits&lt;FP&gt;::is_iec559 &amp;&amp;            &quot;ulpDistance assumes IEEE-754 format for floating point types&quot; );        assert( !Catch::isnan( lhs ) &amp;&amp;                &quot;Distance between NaN and number is not meaningful&quot; );        assert( !Catch::isnan( rhs ) &amp;&amp;                &quot;Distance between NaN and number is not meaningful&quot; );                        if ( lhs == rhs ) { return 0; }                static constexpr FP positive_zero{};                if ( lhs == positive_zero ) { lhs = positive_zero; }        if ( rhs == positive_zero ) { rhs = positive_zero; }                        if ( std::signbit( lhs ) != std::signbit( rhs ) ) {            return ulpDistance( std::abs( lhs ), positive_zero ) +                   ulpDistance( std::abs( rhs ), positive_zero );        }                                uint64_t lc = Detail::convertToBits( lhs );        uint64_t rc = Detail::convertToBits( rhs );                        if ( lc &lt; rc ) {            std::swap( lc, rc );        }        return lc - rc;    }#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif} #endif #ifndef CATCH_GETENV_HPP_INCLUDED#define CATCH_GETENV_HPP_INCLUDEDnamespace Catch {namespace Detail {        char const* getEnv(char const* varName);}}#endif #ifndef CATCH_IS_PERMUTATION_HPP_INCLUDED#define CATCH_IS_PERMUTATION_HPP_INCLUDED#include &lt;iterator&gt;#include &lt;type_traits&gt;namespace Catch {    namespace Detail {        template &lt;typename ForwardIter,                  typename Sentinel,                  typename T,                  typename Comparator&gt;        constexpr        ForwardIter find_sentinel( ForwardIter start,                                   Sentinel sentinel,                                   T const&amp; value,                                   Comparator cmp ) {            while ( start != sentinel ) {                if ( cmp( *start, value ) ) { break; }                ++start;            }            return start;        }        template &lt;typename ForwardIter,                  typename Sentinel,                  typename T,                  typename Comparator&gt;        constexpr        std::ptrdiff_t count_sentinel( ForwardIter start,                                       Sentinel sentinel,                                       T const&amp; value,                                       Comparator cmp ) {            std::ptrdiff_t count = 0;            while ( start != sentinel ) {                if ( cmp( *start, value ) ) { ++count; }                ++start;            }            return count;        }        template &lt;typename ForwardIter, typename Sentinel&gt;        constexpr        std::enable_if_t&lt;!std::is_same&lt;ForwardIter, Sentinel&gt;::value,                         std::ptrdiff_t&gt;        sentinel_distance( ForwardIter iter, const Sentinel sentinel ) {            std::ptrdiff_t dist = 0;            while ( iter != sentinel ) {                ++iter;                ++dist;            }            return dist;        }        template &lt;typename ForwardIter&gt;        constexpr std::ptrdiff_t sentinel_distance( ForwardIter first,                                                    ForwardIter last ) {            return std::distance( first, last );        }        template &lt;typename ForwardIter1,                  typename Sentinel1,                  typename ForwardIter2,                  typename Sentinel2,                  typename Comparator&gt;        constexpr bool check_element_counts( ForwardIter1 first_1,                                             const Sentinel1 end_1,                                             ForwardIter2 first_2,                                             const Sentinel2 end_2,                                             Comparator cmp ) {            auto cursor = first_1;            while ( cursor != end_1 ) {                if ( find_sentinel( first_1, cursor, *cursor, cmp ) ==                     cursor ) {                                        const auto count_in_range_2 =                        count_sentinel( first_2, end_2, *cursor, cmp );                                                            if ( count_in_range_2 == 0 ) { return false; }                    const auto count_in_range_1 =                        count_sentinel( cursor, end_1, *cursor, cmp );                    if ( count_in_range_1 != count_in_range_2 ) {                        return false;                    }                }                ++cursor;            }            return true;        }        template &lt;typename ForwardIter1,                  typename Sentinel1,                  typename ForwardIter2,                  typename Sentinel2,                  typename Comparator&gt;        constexpr bool is_permutation( ForwardIter1 first_1,                                       const Sentinel1 end_1,                                       ForwardIter2 first_2,                                       const Sentinel2 end_2,                                       Comparator cmp ) {                                                while (first_1 != end_1 &amp;&amp; first_2 != end_2 &amp;&amp; cmp(*first_1, *first_2)) {                ++first_1;                ++first_2;            }                        if (first_1 == end_1 || first_2 == end_2) {                return first_1 == end_1 &amp;&amp; first_2 == end_2;            }                        auto dist_1 = sentinel_distance( first_1, end_1 );            auto dist_2 = sentinel_distance( first_2, end_2 );            if (dist_1 != dist_2) { return false; }                                                return check_element_counts( first_1, end_1, first_2, end_2, cmp );        }    } } #endif #ifndef CATCH_ISTREAM_HPP_INCLUDED#define CATCH_ISTREAM_HPP_INCLUDED#include &lt;iosfwd&gt;#include &lt;string&gt;namespace Catch {    class IStream {    public:        virtual ~IStream();         virtual std::ostream&amp; stream() = 0;                virtual bool isConsole() const { return false; }    };        auto makeStream( std::string const&amp; filename ) -&gt; Detail::unique_ptr&lt;IStream&gt;;}#endif #ifndef CATCH_JSONWRITER_HPP_INCLUDED#define CATCH_JSONWRITER_HPP_INCLUDED#include &lt;cstdint&gt;#include &lt;sstream&gt;namespace Catch {    class JsonObjectWriter;    class JsonArrayWriter;    struct JsonUtils {        static void indent( std::ostream&amp; os, std::uint64_t level );        static void appendCommaNewline( std::ostream&amp; os,                                        bool&amp; should_comma,                                        std::uint64_t level );    };    class JsonValueWriter {    public:        JsonValueWriter( std::ostream&amp; os );        JsonValueWriter( std::ostream&amp; os, std::uint64_t indent_level );        JsonObjectWriter writeObject() &amp;&amp;;        JsonArrayWriter writeArray() &amp;&amp;;        template &lt;typename T&gt;        void write( T const&amp; value ) &amp;&amp; {            writeImpl( value, !std::is_arithmetic&lt;T&gt;::value );        }        void write( StringRef value ) &amp;&amp;;        void write( bool value ) &amp;&amp;;    private:        void writeImpl( StringRef value, bool quote );                                        template &lt;typename T,                  typename = typename std::enable_if_t&lt;                      !std::is_convertible&lt;T, StringRef&gt;::value&gt;&gt;        void writeImpl( T const&amp; value, bool quote_value ) {            m_sstream &lt;&lt; value;            writeImpl( m_sstream.str(), quote_value );        }        std::ostream&amp; m_os;        std::stringstream m_sstream;        std::uint64_t m_indent_level;    };    class JsonObjectWriter {    public:        JsonObjectWriter( std::ostream&amp; os );        JsonObjectWriter( std::ostream&amp; os, std::uint64_t indent_level );        JsonObjectWriter( JsonObjectWriter&amp;&amp; source ) noexcept;        JsonObjectWriter&amp; operator=( JsonObjectWriter&amp;&amp; source ) = delete;        ~JsonObjectWriter();        JsonValueWriter write( StringRef key );    private:        std::ostream&amp; m_os;        std::uint64_t m_indent_level;        bool m_should_comma = false;        bool m_active = true;    };    class JsonArrayWriter {    public:        JsonArrayWriter( std::ostream&amp; os );        JsonArrayWriter( std::ostream&amp; os, std::uint64_t indent_level );        JsonArrayWriter( JsonArrayWriter&amp;&amp; source ) noexcept;        JsonArrayWriter&amp; operator=( JsonArrayWriter&amp;&amp; source ) = delete;        ~JsonArrayWriter();        JsonObjectWriter writeObject();        JsonArrayWriter writeArray();        template &lt;typename T&gt;        JsonArrayWriter&amp; write( T const&amp; value ) {            return writeImpl( value );        }        JsonArrayWriter&amp; write( bool value );    private:        template &lt;typename T&gt;        JsonArrayWriter&amp; writeImpl( T const&amp; value ) {            JsonUtils::appendCommaNewline(                m_os, m_should_comma, m_indent_level + 1 );            JsonValueWriter{ m_os }.write( value );            return *this;        }        std::ostream&amp; m_os;        std::uint64_t m_indent_level;        bool m_should_comma = false;        bool m_active = true;    };} #endif #ifndef CATCH_LEAK_DETECTOR_HPP_INCLUDED#define CATCH_LEAK_DETECTOR_HPP_INCLUDEDnamespace Catch {    struct LeakDetector {        LeakDetector();        ~LeakDetector();    };}#endif #ifndef CATCH_LIST_HPP_INCLUDED#define CATCH_LIST_HPP_INCLUDED#include &lt;set&gt;#include &lt;string&gt;namespace Catch {    class IEventListener;    class Config;    struct ReporterDescription {        std::string name, description;    };    struct ListenerDescription {        StringRef name;        std::string description;    };    struct TagInfo {        void add(StringRef spelling);        std::string all() const;        std::set&lt;StringRef&gt; spellings;        std::size_t count = 0;    };    bool list( IEventListener&amp; reporter, Config const&amp; config );} #endif #ifndef CATCH_OUTPUT_REDIRECT_HPP_INCLUDED#define CATCH_OUTPUT_REDIRECT_HPP_INCLUDED#include &lt;cassert&gt;#include &lt;string&gt;namespace Catch {    class OutputRedirect {        bool m_redirectActive = false;        virtual void activateImpl() = 0;        virtual void deactivateImpl() = 0;    public:        enum Kind {                        None,                        Streams,                        FileDescriptors,        };        virtual ~OutputRedirect();                 virtual std::string getStdout() = 0;        virtual std::string getStderr() = 0;        virtual void clearBuffers() = 0;        bool isActive() const { return m_redirectActive; }        void activate() {            assert( !m_redirectActive &amp;&amp; &quot;redirect is already active&quot; );            activateImpl();            m_redirectActive = true;        }        void deactivate() {            assert( m_redirectActive &amp;&amp; &quot;redirect is not active&quot; );            deactivateImpl();            m_redirectActive = false;        }    };    bool isRedirectAvailable( OutputRedirect::Kind kind);    Detail::unique_ptr&lt;OutputRedirect&gt; makeOutputRedirect( bool actual );    class RedirectGuard {        OutputRedirect* m_redirect;        bool m_activate;        bool m_previouslyActive;        bool m_moved = false;    public:        RedirectGuard( bool activate, OutputRedirect&amp; redirectImpl );        ~RedirectGuard() noexcept( false );        RedirectGuard( RedirectGuard const&amp; ) = delete;        RedirectGuard&amp; operator=( RedirectGuard const&amp; ) = delete;                RedirectGuard( RedirectGuard&amp;&amp; rhs ) noexcept;        RedirectGuard&amp; operator=( RedirectGuard&amp;&amp; rhs ) noexcept;    };    RedirectGuard scopedActivate( OutputRedirect&amp; redirectImpl );    RedirectGuard scopedDeactivate( OutputRedirect&amp; redirectImpl );} #endif #ifndef CATCH_PARSE_NUMBERS_HPP_INCLUDED#define CATCH_PARSE_NUMBERS_HPP_INCLUDED#include &lt;string&gt;namespace Catch {        Optional&lt;unsigned int&gt; parseUInt(std::string const&amp; input, int base = 10);}#endif #ifndef CATCH_REPORTER_REGISTRY_HPP_INCLUDED#define CATCH_REPORTER_REGISTRY_HPP_INCLUDED#include &lt;map&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace Catch {    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr&lt;IEventListener&gt;;    class IReporterFactory;    using IReporterFactoryPtr = Detail::unique_ptr&lt;IReporterFactory&gt;;    struct ReporterConfig;    class EventListenerFactory;    class ReporterRegistry {        struct ReporterRegistryImpl;        Detail::unique_ptr&lt;ReporterRegistryImpl&gt; m_impl;    public:        ReporterRegistry();        ~ReporterRegistry();         IEventListenerPtr create( std::string const&amp; name,                                  ReporterConfig&amp;&amp; config ) const;        void registerReporter( std::string const&amp; name,                               IReporterFactoryPtr factory );        void        registerListener( Detail::unique_ptr&lt;EventListenerFactory&gt; factory );        std::map&lt;std::string,                 IReporterFactoryPtr,                 Detail::CaseInsensitiveLess&gt; const&amp;        getFactories() const;        std::vector&lt;Detail::unique_ptr&lt;EventListenerFactory&gt;&gt; const&amp;        getListeners() const;    };} #endif #ifndef CATCH_RUN_CONTEXT_HPP_INCLUDED#define CATCH_RUN_CONTEXT_HPP_INCLUDED#ifndef CATCH_TEST_CASE_TRACKER_HPP_INCLUDED#define CATCH_TEST_CASE_TRACKER_HPP_INCLUDED#include &lt;string&gt;#include &lt;vector&gt;namespace Catch {namespace TestCaseTracking {    struct NameAndLocation {        std::string name;        SourceLineInfo location;        NameAndLocation( std::string&amp;&amp; _name, SourceLineInfo const&amp; _location );        friend bool operator==(NameAndLocation const&amp; lhs, NameAndLocation const&amp; rhs) {                                                            if ( lhs.location.line != rhs.location.line ) { return false; }            return lhs.name == rhs.name &amp;&amp; lhs.location == rhs.location;        }        friend bool operator!=(NameAndLocation const&amp; lhs,                               NameAndLocation const&amp; rhs) {            return !( lhs == rhs );        }    };        struct NameAndLocationRef {        StringRef name;        SourceLineInfo location;        constexpr NameAndLocationRef( StringRef name_,                                      SourceLineInfo location_ ):            name( name_ ), location( location_ ) {}        friend bool operator==( NameAndLocation const&amp; lhs,                                NameAndLocationRef const&amp; rhs ) {                                                            if ( lhs.location.line != rhs.location.line ) { return false; }            return StringRef( lhs.name ) == rhs.name &amp;&amp;                   lhs.location == rhs.location;        }        friend bool operator==( NameAndLocationRef const&amp; lhs,                                NameAndLocation const&amp; rhs ) {            return rhs == lhs;        }    };    class ITracker;    using ITrackerPtr = <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Catch::Detail::unique_ptr</a>&lt;ITracker&gt;;    class ITracker {        NameAndLocation m_nameAndLocation;        using Children = std::vector&lt;ITrackerPtr&gt;;    protected:        enum CycleState {            NotStarted,            Executing,            ExecutingChildren,            NeedsAnotherRun,            CompletedSuccessfully,            Failed        };        ITracker* m_parent = nullptr;        Children m_children;        CycleState m_runState = NotStarted;    public:        ITracker( NameAndLocation&amp;&amp; nameAndLoc, ITracker* parent ):            m_nameAndLocation( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(nameAndLoc) ),            m_parent( parent )        {}                NameAndLocation const&amp; nameAndLocation() const {            return m_nameAndLocation;        }        ITracker* parent() const {            return m_parent;        }        virtual ~ITracker();                         virtual bool isComplete() const = 0;                bool isSuccessfullyCompleted() const {            return m_runState == CompletedSuccessfully;        }                bool isOpen() const;                bool hasStarted() const;                virtual void close() = 0;         virtual void fail() = 0;        void markAsNeedingAnotherRun();                void addChild( ITrackerPtr&amp;&amp; child );                ITracker* findChild( NameAndLocationRef const&amp; nameAndLocation );                bool hasChildren() const {            return !m_children.empty();        }                void openChild();                virtual bool isSectionTracker() const;                virtual bool isGeneratorTracker() const;    };    class TrackerContext {        enum RunState {            NotStarted,            Executing,            CompletedCycle        };        ITrackerPtr m_rootTracker;        ITracker* m_currentTracker = nullptr;        RunState m_runState = NotStarted;    public:        ITracker&amp; startRun();        void startCycle() {            m_currentTracker = m_rootTracker.get();            m_runState = Executing;        }        void completeCycle();        bool completedCycle() const;        ITracker&amp; currentTracker() { return *m_currentTracker; }        void setCurrentTracker( ITracker* tracker );    };    class TrackerBase : public ITracker {    protected:        TrackerContext&amp; m_ctx;    public:        TrackerBase( NameAndLocation&amp;&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent );        bool isComplete() const override;        void open();        void close() override;        void fail() override;    private:        void moveToParent();        void moveToThis();    };    class SectionTracker : public TrackerBase {        std::vector&lt;StringRef&gt; m_filters;                                        StringRef m_trimmed_name;    public:        SectionTracker( NameAndLocation&amp;&amp; nameAndLocation, TrackerContext&amp; ctx, ITracker* parent );        bool isSectionTracker() const override;        bool isComplete() const override;        static SectionTracker&amp; acquire( TrackerContext&amp; ctx, NameAndLocationRef const&amp; nameAndLocation );        void tryOpen();        void addInitialFilters( std::vector&lt;std::string&gt; const&amp; filters );        void addNextFilters( std::vector&lt;StringRef&gt; const&amp; filters );                std::vector&lt;StringRef&gt; const&amp; getFilters() const { return m_filters; }                StringRef trimmedName() const;    };} using TestCaseTracking::ITracker;using TestCaseTracking::TrackerContext;using TestCaseTracking::SectionTracker;} #endif #ifndef CATCH_THREAD_SUPPORT_HPP_INCLUDED#define CATCH_THREAD_SUPPORT_HPP_INCLUDED#if defined( CATCH_CONFIG_EXPERIMENTAL_THREAD_SAFE_ASSERTIONS )#    include &lt;atomic&gt;#    include &lt;mutex&gt;#endifnamespace Catch {    namespace Detail {#if defined( CATCH_CONFIG_EXPERIMENTAL_THREAD_SAFE_ASSERTIONS )        using Mutex = std::mutex;        using LockGuard = std::lock_guard&lt;std::mutex&gt;;        struct AtomicCounts {            std::atomic&lt;std::uint64_t&gt; passed = 0;            std::atomic&lt;std::uint64_t&gt; failed = 0;            std::atomic&lt;std::uint64_t&gt; failedButOk = 0;            std::atomic&lt;std::uint64_t&gt; skipped = 0;        };#else               struct Mutex {            void lock() {}            void unlock() {}        };        struct LockGuard {            LockGuard( Mutex ) {}        };        using AtomicCounts = Counts;#endif    } } #endif #include &lt;string&gt;namespace Catch {    class IGeneratorTracker;    class IConfig;    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr&lt;IEventListener&gt;;    class OutputRedirect;        class RunContext final : public IResultCapture {    public:        RunContext( RunContext const&amp; ) = delete;        RunContext&amp; operator =( RunContext const&amp; ) = delete;        explicit RunContext( IConfig const* _config, IEventListenerPtr&amp;&amp; reporter );        ~RunContext() override;        Totals runTest(TestCaseHandle const&amp; testCase);    public:                 void handleExpr                (   AssertionInfo const&amp; info,                    ITransientExpression const&amp; expr,                    AssertionReaction&amp; reaction ) override;        void handleMessage                (   AssertionInfo const&amp; info,                    ResultWas::OfType resultType,                    std::string&amp;&amp; message,                    AssertionReaction&amp; reaction ) override;        void handleUnexpectedExceptionNotThrown                (   AssertionInfo const&amp; info,                    AssertionReaction&amp; reaction ) override;        void handleUnexpectedInflightException                (   AssertionInfo const&amp; info,                    std::string&amp;&amp; message,                    AssertionReaction&amp; reaction ) override;        void handleIncomplete                (   AssertionInfo const&amp; info ) override;        void handleNonExpr                (   AssertionInfo const &amp;info,                    ResultWas::OfType resultType,                    AssertionReaction &amp;reaction ) override;        void notifyAssertionStarted( AssertionInfo const&amp; info ) override;        bool sectionStarted( StringRef sectionName,                             SourceLineInfo const&amp; sectionLineInfo,                             Counts&amp; assertions ) override;        void sectionEnded( SectionEndInfo&amp;&amp; endInfo ) override;        void sectionEndedEarly( SectionEndInfo&amp;&amp; endInfo ) override;        IGeneratorTracker*        acquireGeneratorTracker( StringRef generatorName,                                 SourceLineInfo const&amp; lineInfo ) override;        IGeneratorTracker* createGeneratorTracker(            StringRef generatorName,            SourceLineInfo lineInfo,            Generators::GeneratorBasePtr&amp;&amp; generator ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const&amp; info ) override;        void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; stats ) override;        void benchmarkFailed( StringRef error ) override;        void pushScopedMessage( MessageInfo const&amp; message ) override;        void popScopedMessage( MessageInfo const&amp; message ) override;        void emplaceUnscopedMessage( MessageBuilder&amp;&amp; builder ) override;        std::string getCurrentTestName() const override;        const AssertionResult* getLastResult() const override;        void exceptionEarlyReported() override;        void handleFatalErrorCondition( StringRef message ) override;        bool lastAssertionPassed() override;    public:                bool aborting() const;    private:        void assertionPassedFastPath( SourceLineInfo lineInfo );                void updateTotalsFromAtomics();        void runCurrentTest();        void invokeActiveTestCase();        bool testForMissingAssertions( Counts&amp; assertions );        void assertionEnded( AssertionResult&amp;&amp; result );        void reportExpr                (   AssertionInfo const &amp;info,                    ResultWas::OfType resultType,                    ITransientExpression const *expr,                    bool negated );        void populateReaction( AssertionReaction&amp; reaction, bool has_normal_disposition );                                AssertionInfo makeDummyAssertionInfo();    private:        void handleUnfinishedSections();        mutable Detail::Mutex m_assertionMutex;        TestRunInfo m_runInfo;        TestCaseHandle const* m_activeTestCase = nullptr;        ITracker* m_testCaseTracker = nullptr;        Optional&lt;AssertionResult&gt; m_lastResult;        IConfig const* m_config;        Totals m_totals;        Detail::AtomicCounts m_atomicAssertionCount;        IEventListenerPtr m_reporter;        std::vector&lt;SectionEndInfo&gt; m_unfinishedSections;        std::vector&lt;ITracker*&gt; m_activeSections;        TrackerContext m_trackerContext;        Detail::unique_ptr&lt;OutputRedirect&gt; m_outputRedirect;        FatalConditionHandler m_fatalConditionhandler;                size_t m_abortAfterXFailedAssertions;        bool m_shouldReportUnexpected = true;                bool m_reportAssertionStarting;                bool m_includeSuccessfulResults;                bool m_shouldDebugBreak;    };    void seedRng(IConfig const&amp; config);    unsigned int rngSeed();} #endif #ifndef CATCH_SHARDING_HPP_INCLUDED#define CATCH_SHARDING_HPP_INCLUDED#include &lt;cassert&gt;#include &lt;algorithm&gt;namespace Catch {    template&lt;typename Container&gt;    Container createShard(Container const&amp; container, std::size_t const shardCount, std::size_t const shardIndex) {        assert(shardCount &gt; shardIndex);        if (shardCount == 1) {            return container;        }        const std::size_t totalTestCount = container.size();        const std::size_t shardSize = totalTestCount / shardCount;        const std::size_t leftoverTests = totalTestCount % shardCount;        const std::size_t startIndex = shardIndex * shardSize + (std::min)(shardIndex, leftoverTests);        const std::size_t endIndex = (shardIndex + 1) * shardSize + (std::min)(shardIndex + 1, leftoverTests);        auto startIterator = std::next(container.begin(), static_cast&lt;std::ptrdiff_t&gt;(startIndex));        auto endIterator = std::next(container.begin(), static_cast&lt;std::ptrdiff_t&gt;(endIndex));        return Container(startIterator, endIterator);    }}#endif #ifndef CATCH_SINGLETONS_HPP_INCLUDED#define CATCH_SINGLETONS_HPP_INCLUDEDnamespace Catch {    struct ISingleton {        virtual ~ISingleton();     };    void addSingleton( ISingleton* singleton );    void cleanupSingletons();    template&lt;typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT&gt;    class Singleton : SingletonImplT, public ISingleton {        static auto getInternal() -&gt; Singleton* {            static Singleton* s_instance = nullptr;            if( !s_instance ) {                s_instance = new Singleton;                addSingleton( s_instance );            }            return s_instance;        }    public:        static auto get() -&gt; InterfaceT const&amp; {            return *getInternal();        }        static auto getMutable() -&gt; MutableInterfaceT&amp; {            return *getInternal();        }    };} #endif #ifndef CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED#define CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED#include &lt;vector&gt;#include &lt;exception&gt;namespace Catch {    class StartupExceptionRegistry {#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)    public:        void add(std::exception_ptr const&amp; exception) noexcept;        std::vector&lt;std::exception_ptr&gt; const&amp; getExceptions() const noexcept;    private:        std::vector&lt;std::exception_ptr&gt; m_exceptions;#endif    };} #endif #ifndef CATCH_STDSTREAMS_HPP_INCLUDED#define CATCH_STDSTREAMS_HPP_INCLUDED#include &lt;iosfwd&gt;namespace Catch {    std::ostream&amp; cout();    std::ostream&amp; cerr();    std::ostream&amp; clog();} #endif#ifndef CATCH_STRING_MANIP_HPP_INCLUDED#define CATCH_STRING_MANIP_HPP_INCLUDED#include &lt;cstdint&gt;#include &lt;string&gt;#include &lt;iosfwd&gt;#include &lt;vector&gt;namespace Catch {    bool startsWith( std::string const&amp; s, std::string const&amp; prefix );    bool startsWith( StringRef s, char prefix );    bool endsWith( std::string const&amp; s, std::string const&amp; suffix );    bool endsWith( std::string const&amp; s, char suffix );    bool contains( std::string const&amp; s, std::string const&amp; infix );    void toLowerInPlace( std::string&amp; s );    std::string toLower( std::string const&amp; s );    char toLower( char c );        std::string trim( std::string const&amp; str );        StringRef trim(StringRef ref);        std::vector&lt;StringRef&gt; splitStringRef( StringRef str, char delimiter );    bool replaceInPlace( std::string&amp; str, std::string const&amp; replaceThis, std::string const&amp; withThis );        class pluralise {        std::uint64_t m_count;        StringRef m_label;    public:        constexpr pluralise(std::uint64_t count, StringRef label):            m_count(count),            m_label(label)        {}        friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, pluralise const&amp; pluraliser );    };}#endif #ifndef CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED#define CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED#include &lt;map&gt;#include &lt;string&gt;namespace Catch {    struct SourceLineInfo;    class TagAliasRegistry : public ITagAliasRegistry {    public:        ~TagAliasRegistry() override;        TagAlias const* find( std::string const&amp; alias ) const override;        std::string expandAliases( std::string const&amp; unexpandedTestSpec ) const override;        void add( std::string const&amp; alias, std::string const&amp; tag, SourceLineInfo const&amp; lineInfo );    private:        std::map&lt;std::string, TagAlias&gt; m_registry;    };} #endif #ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED#include &lt;cstdint&gt;namespace Catch {    struct TestCaseInfo;    class TestCaseInfoHasher {    public:        using hash_t = std::uint64_t;        TestCaseInfoHasher( hash_t seed );        uint32_t operator()( TestCaseInfo const&amp; t ) const;    private:        hash_t m_seed;    };} #endif #ifndef CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED#define CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED#include &lt;vector&gt;namespace Catch {    class IConfig;    class ITestInvoker;    class TestCaseHandle;    class TestSpec;    std::vector&lt;TestCaseHandle&gt; sortTests( IConfig const&amp; config, std::vector&lt;TestCaseHandle&gt; const&amp; unsortedTestCases );    bool isThrowSafe( TestCaseHandle const&amp; testCase, IConfig const&amp; config );    std::vector&lt;TestCaseHandle&gt; filterTests( std::vector&lt;TestCaseHandle&gt; const&amp; testCases, TestSpec const&amp; testSpec, IConfig const&amp; config );    std::vector&lt;TestCaseHandle&gt; const&amp; getAllTestCasesSorted( IConfig const&amp; config );    class TestRegistry : public ITestCaseRegistry {    public:        void registerTest( Detail::unique_ptr&lt;TestCaseInfo&gt; testInfo, Detail::unique_ptr&lt;ITestInvoker&gt; testInvoker );        std::vector&lt;TestCaseInfo*&gt; const&amp; getAllInfos() const override;        std::vector&lt;TestCaseHandle&gt; const&amp; getAllTests() const override;        std::vector&lt;TestCaseHandle&gt; const&amp; getAllTestsSorted( IConfig const&amp; config ) const override;        ~TestRegistry() override;     private:        std::vector&lt;Detail::unique_ptr&lt;TestCaseInfo&gt;&gt; m_owned_test_infos;                        std::vector&lt;TestCaseInfo*&gt; m_viewed_test_infos;        std::vector&lt;Detail::unique_ptr&lt;ITestInvoker&gt;&gt; m_invokers;        std::vector&lt;TestCaseHandle&gt; m_handles;        mutable TestRunOrder m_currentSortOrder = TestRunOrder::Declared;        mutable std::vector&lt;TestCaseHandle&gt; m_sortedFunctions;    };    } #endif #ifndef CATCH_TEST_SPEC_PARSER_HPP_INCLUDED#define CATCH_TEST_SPEC_PARSER_HPP_INCLUDED#ifdef __clang__#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wpadded&quot;#endif#include &lt;vector&gt;#include &lt;string&gt;namespace Catch {    class ITagAliasRegistry;    class TestSpecParser {        enum Mode{ None, Name, QuotedName, Tag, EscapedName };        Mode m_mode = None;        Mode lastMode = None;        bool m_exclusion = false;        std::size_t m_pos = 0;        std::size_t m_realPatternPos = 0;        std::string m_arg;        std::string m_substring;        std::string m_patternName;        std::vector&lt;std::size_t&gt; m_escapeChars;        TestSpec::Filter m_currentFilter;        TestSpec m_testSpec;        ITagAliasRegistry const* m_tagAliases = nullptr;    public:        TestSpecParser( ITagAliasRegistry const&amp; tagAliases );        TestSpecParser&amp; parse( std::string const&amp; arg );        TestSpec testSpec();    private:        bool visitChar( char c );        void startNewMode( Mode mode );        bool processNoneChar( char c );        void processNameChar( char c );        bool processOtherChar( char c );        void endMode();        void escape();        bool isControlChar( char c ) const;        void saveLastMode();        void revertBackToLastMode();        void addFilter();        bool separate();                std::string preprocessPattern();                void addNamePattern();                void addTagPattern();        inline void addCharToPattern(char c) {            m_substring += c;            m_patternName += c;            m_realPatternPos++;        }    };} #ifdef __clang__#pragma clang diagnostic pop#endif#endif #ifndef CATCH_TEXTFLOW_HPP_INCLUDED#define CATCH_TEXTFLOW_HPP_INCLUDED#include &lt;cassert&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace Catch {    namespace TextFlow {        class Columns;                class AnsiSkippingString {            std::string m_string;            std::size_t m_size = 0;                        void preprocessString();        public:            class const_iterator;            using iterator = const_iterator;                                    static constexpr char sentinel = static_cast&lt;char&gt;( 0xffu );            explicit AnsiSkippingString( std::string const&amp; text );            explicit AnsiSkippingString( std::string&amp;&amp; text );            const_iterator begin() const;            const_iterator end() const;            size_t size() const { return m_size; }            std::string substring( const_iterator begin,                                   const_iterator end ) const;        };        class AnsiSkippingString::const_iterator {            friend AnsiSkippingString;            struct EndTag {};            const std::string* m_string;            std::string::const_iterator m_it;            explicit const_iterator( const std::string&amp; string, EndTag ):                m_string( &amp;string ), m_it( string.end() ) {}            void tryParseAnsiEscapes();            void advance();            void unadvance();        public:            using difference_type = std::ptrdiff_t;            using value_type = char;            using pointer = value_type*;            using reference = value_type&amp;;            using iterator_category = std::bidirectional_iterator_tag;            explicit const_iterator( const std::string&amp; string ):                m_string( &amp;string ), m_it( string.begin() ) {                tryParseAnsiEscapes();            }            char operator*() const { return *m_it; }            const_iterator&amp; operator++() {                advance();                return *this;            }            const_iterator operator++( int ) {                iterator prev( *this );                operator++();                return prev;            }            const_iterator&amp; operator--() {                unadvance();                return *this;            }            const_iterator operator--( int ) {                iterator prev( *this );                operator--();                return prev;            }            bool operator==( const_iterator const&amp; other ) const {                return m_it == other.m_it;            }            bool operator!=( const_iterator const&amp; other ) const {                return !operator==( other );            }            bool operator&lt;=( const_iterator const&amp; other ) const {                return m_it &lt;= other.m_it;            }            const_iterator oneBefore() const {                auto it = *this;                return --it;            }        };                class Column {                        AnsiSkippingString m_string;                        size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;                                    size_t m_indent = 0;                        size_t m_initialIndent = std::string::npos;        public:                        class const_iterator {                friend Column;                struct EndTag {};                Column const&amp; m_column;                                AnsiSkippingString::const_iterator m_lineStart;                                AnsiSkippingString::const_iterator m_lineEnd;                                AnsiSkippingString::const_iterator m_parsedTo;                                bool m_addHyphen = false;                const_iterator( Column const&amp; column, EndTag ):                    m_column( column ),                    m_lineStart( m_column.m_string.end() ),                    m_lineEnd( column.m_string.end() ),                    m_parsedTo( column.m_string.end() ) {}                                void calcLength();                                size_t indentSize() const;                                                std::string addIndentAndSuffix(                    AnsiSkippingString::const_iterator start,                    AnsiSkippingString::const_iterator end ) const;            public:                using difference_type = std::ptrdiff_t;                using value_type = std::string;                using pointer = value_type*;                using reference = value_type&amp;;                using iterator_category = std::forward_iterator_tag;                explicit const_iterator( Column const&amp; column );                std::string operator*() const;                const_iterator&amp; operator++();                const_iterator operator++( int );                bool operator==( const_iterator const&amp; other ) const {                    return m_lineStart == other.m_lineStart &amp;&amp;                           &amp;m_column == &amp;other.m_column;                }                bool operator!=( const_iterator const&amp; other ) const {                    return !operator==( other );                }            };            using iterator = const_iterator;            explicit Column( std::string const&amp; text ): m_string( text ) {}            explicit Column( std::string&amp;&amp; text ):                m_string( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>( text ) ) {}            Column&amp; width( size_t newWidth ) &amp; {                assert( newWidth &gt; 0 );                m_width = newWidth;                return *this;            }            Column&amp;&amp; width( size_t newWidth ) &amp;&amp; {                assert( newWidth &gt; 0 );                m_width = newWidth;                return <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>( *this );            }            Column&amp; indent( size_t newIndent ) &amp; {                m_indent = newIndent;                return *this;            }            Column&amp;&amp; indent( size_t newIndent ) &amp;&amp; {                m_indent = newIndent;                return <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>( *this );            }            Column&amp; initialIndent( size_t newIndent ) &amp; {                m_initialIndent = newIndent;                return *this;            }            Column&amp;&amp; initialIndent( size_t newIndent ) &amp;&amp; {                m_initialIndent = newIndent;                return <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>( *this );            }            size_t width() const { return m_width; }            const_iterator begin() const { return const_iterator( *this ); }            const_iterator end() const {                return { *this, const_iterator::EndTag{} };            }            friend std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,                                             Column const&amp; col );            friend Columns operator+( Column const&amp; lhs, Column const&amp; rhs );            friend Columns operator+( Column&amp;&amp; lhs, Column&amp;&amp; rhs );        };                Column Spacer( size_t spaceWidth );        class Columns {            std::vector&lt;Column&gt; m_columns;        public:            class iterator {                friend Columns;                struct EndTag {};                std::vector&lt;Column&gt; const&amp; m_columns;                std::vector&lt;Column::const_iterator&gt; m_iterators;                size_t m_activeIterators;                iterator( Columns const&amp; columns, EndTag );            public:                using difference_type = std::ptrdiff_t;                using value_type = std::string;                using pointer = value_type*;                using reference = value_type&amp;;                using iterator_category = std::forward_iterator_tag;                explicit iterator( Columns const&amp; columns );                auto operator==( iterator const&amp; other ) const -&gt; bool {                    return m_iterators == other.m_iterators;                }                auto operator!=( iterator const&amp; other ) const -&gt; bool {                    return m_iterators != other.m_iterators;                }                std::string operator*() const;                iterator&amp; operator++();                iterator operator++( int );            };            using const_iterator = iterator;            iterator begin() const { return iterator( *this ); }            iterator end() const { return { *this, iterator::EndTag() }; }            friend Columns&amp; operator+=( Columns&amp; lhs, Column const&amp; rhs );            friend Columns&amp; operator+=( Columns&amp; lhs, Column&amp;&amp; rhs );            friend Columns operator+( Columns const&amp; lhs, Column const&amp; rhs );            friend Columns operator+( Columns&amp;&amp; lhs, Column&amp;&amp; rhs );            friend std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os,                                             Columns const&amp; cols );        };    } } #endif #ifndef CATCH_TO_STRING_HPP_INCLUDED#define CATCH_TO_STRING_HPP_INCLUDED#include &lt;string&gt;namespace Catch {    template &lt;typename T&gt;    std::string to_string(T const&amp; t) {#if defined(CATCH_CONFIG_CPP11_TO_STRING)        return std::to_string(t);#else        ReusableStringStream rss;        rss &lt;&lt; t;        return rss.str();#endif    }} #endif #ifndef CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#define CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDEDnamespace Catch {    bool uncaught_exceptions();} #endif #ifndef CATCH_XMLWRITER_HPP_INCLUDED#define CATCH_XMLWRITER_HPP_INCLUDED#include &lt;iosfwd&gt;#include &lt;vector&gt;#include &lt;cstdint&gt;namespace Catch {    enum class XmlFormatting : std::uint8_t {        None = 0x00,        Indent = 0x01,        Newline = 0x02,    };    constexpr XmlFormatting operator|( XmlFormatting lhs, XmlFormatting rhs ) {        return static_cast&lt;XmlFormatting&gt;( static_cast&lt;std::uint8_t&gt;( lhs ) |                                           static_cast&lt;std::uint8_t&gt;( rhs ) );    }    constexpr XmlFormatting operator&amp;( XmlFormatting lhs, XmlFormatting rhs ) {        return static_cast&lt;XmlFormatting&gt;( static_cast&lt;std::uint8_t&gt;( lhs ) &amp;                                           static_cast&lt;std::uint8_t&gt;( rhs ) );    }        class XmlEncode {    public:        enum ForWhat { ForTextNodes, ForAttributes };        constexpr XmlEncode( StringRef str, ForWhat forWhat = ForTextNodes ):            m_str( str ), m_forWhat( forWhat ) {}        void encodeTo( std::ostream&amp; os ) const;        friend std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, XmlEncode const&amp; xmlEncode );    private:        StringRef m_str;        ForWhat m_forWhat;    };    class XmlWriter {    public:        class ScopedElement {        public:            ScopedElement( XmlWriter* writer, XmlFormatting fmt );            ScopedElement( ScopedElement&amp;&amp; other ) noexcept;            ScopedElement&amp; operator=( ScopedElement&amp;&amp; other ) noexcept;            ~ScopedElement();            ScopedElement&amp;            writeText( StringRef text,                       XmlFormatting fmt = XmlFormatting::Newline |                                           XmlFormatting::Indent );            ScopedElement&amp; writeAttribute( StringRef name,                                           StringRef attribute );            template &lt;typename T,                                                                                                              typename = typename std::enable_if_t&lt;                          !std::is_convertible&lt;T, StringRef&gt;::value&gt;&gt;            ScopedElement&amp; writeAttribute( StringRef name,                                           T const&amp; attribute ) {                m_writer-&gt;writeAttribute( name, attribute );                return *this;            }        private:            XmlWriter* m_writer = nullptr;            XmlFormatting m_fmt;        };        XmlWriter( std::ostream&amp; os );        ~XmlWriter();        XmlWriter( XmlWriter const&amp; ) = delete;        XmlWriter&amp; operator=( XmlWriter const&amp; ) = delete;        XmlWriter&amp; startElement( std::string const&amp; name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);        ScopedElement scopedElement( std::string const&amp; name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);        XmlWriter&amp; endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);                XmlWriter&amp; writeAttribute( StringRef name, StringRef attribute );                XmlWriter&amp; writeAttribute( StringRef name, bool attribute );                XmlWriter&amp; writeAttribute( StringRef name, char const* attribute );                        template &lt;typename T,                                                                                          typename = typename std::enable_if_t&lt;                      !std::is_convertible&lt;T, StringRef&gt;::value&gt;&gt;        XmlWriter&amp; writeAttribute( StringRef name, T const&amp; attribute ) {            ReusableStringStream rss;            rss &lt;&lt; attribute;            return writeAttribute( name, rss.str() );        }                XmlWriter&amp; writeText( StringRef text,                              XmlFormatting fmt = XmlFormatting::Newline |                                                  XmlFormatting::Indent );                XmlWriter&amp; writeComment( StringRef text,                                 XmlFormatting fmt = XmlFormatting::Newline |                                                     XmlFormatting::Indent );        void writeStylesheetRef( StringRef url );        void ensureTagClosed();    private:        void applyFormatting(XmlFormatting fmt);        void writeDeclaration();        void newlineIfNecessary();        bool m_tagIsOpen = false;        bool m_needsNewline = false;        std::vector&lt;std::string&gt; m_tags;        std::string m_indent;        std::ostream&amp; m_os;    };}#endif #ifndef CATCH_MATCHERS_ALL_HPP_INCLUDED#define CATCH_MATCHERS_ALL_HPP_INCLUDED#ifndef CATCH_MATCHERS_HPP_INCLUDED#define CATCH_MATCHERS_HPP_INCLUDED#ifndef CATCH_MATCHERS_IMPL_HPP_INCLUDED#define CATCH_MATCHERS_IMPL_HPP_INCLUDED#include &lt;string&gt;namespace Catch {#ifdef __clang__#    pragma clang diagnostic push#    pragma clang diagnostic ignored &quot;-Wsign-compare&quot;#    pragma clang diagnostic ignored &quot;-Wnon-virtual-dtor&quot;#elif defined __GNUC__#    pragma GCC diagnostic push#    pragma GCC diagnostic ignored &quot;-Wsign-compare&quot;#    pragma GCC diagnostic ignored &quot;-Wnon-virtual-dtor&quot;#endif    template&lt;typename ArgT, typename MatcherT&gt;    class MatchExpr : public ITransientExpression {        ArgT &amp;&amp; m_arg;        MatcherT const&amp; m_matcher;    public:        constexpr MatchExpr( ArgT &amp;&amp; arg, MatcherT const&amp; matcher )        :   ITransientExpression{ true, matcher.match( arg ) },             m_arg( <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(arg) ),            m_matcher( matcher )        {}        void streamReconstructedExpression( std::ostream&amp; os ) const override {            os &lt;&lt; Catch::Detail::stringify( m_arg )               &lt;&lt; ' '               &lt;&lt; m_matcher.toString();        }    };#ifdef __clang__#    pragma clang diagnostic pop#elif defined __GNUC__#    pragma GCC diagnostic pop#endif    namespace Matchers {        template &lt;typename ArgT&gt;        class MatcherBase;    }    using StringMatcher = Matchers::MatcherBase&lt;std::string&gt;;    void handleExceptionMatchExpr( AssertionHandler&amp; handler, StringMatcher const&amp; matcher );    template&lt;typename ArgT, typename MatcherT&gt;    constexpr MatchExpr&lt;ArgT, MatcherT&gt;    makeMatchExpr( ArgT&amp;&amp; arg, MatcherT const&amp; matcher ) {        return MatchExpr&lt;ArgT, MatcherT&gt;( <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(arg), matcher );    }} #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \    do { \        <a class="el" href="classCatch_1_1AssertionHandler.html">Catch::AssertionHandler</a> catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \        INTERNAL_CATCH_TRY { \            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher ) ); \        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \        catchAssertionHandler.complete(); \    } while( false )#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \    do { \        <a class="el" href="classCatch_1_1AssertionHandler.html">Catch::AssertionHandler</a> catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(exceptionType) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \        if( catchAssertionHandler.allowThrows() ) \            try { \                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \                static_cast&lt;void&gt;(__VA_ARGS__ ); \                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \            } \            catch( exceptionType const&amp; ex ) { \                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher ) ); \            } \            catch( ... ) { \                catchAssertionHandler.handleUnexpectedInflightException(); \            } \        else \            catchAssertionHandler.handleThrowingCallSkipped(); \        catchAssertionHandler.complete(); \    } while( false )#endif #include &lt;string&gt;#include &lt;vector&gt;namespace Catch {namespace Matchers {    class MatcherUntypedBase {    public:        MatcherUntypedBase() = default;        MatcherUntypedBase(MatcherUntypedBase const&amp;) = default;        MatcherUntypedBase(MatcherUntypedBase&amp;&amp;) = default;        MatcherUntypedBase&amp; operator = (MatcherUntypedBase const&amp;) = delete;        MatcherUntypedBase&amp; operator = (MatcherUntypedBase&amp;&amp;) = delete;        std::string toString() const;    protected:        virtual ~MatcherUntypedBase();         virtual std::string describe() const = 0;        mutable std::string m_cachedToString;    };    template&lt;typename T&gt;    class MatcherBase : public MatcherUntypedBase {    public:        virtual bool match( T const&amp; arg ) const = 0;    };    namespace Detail {        template&lt;typename ArgT&gt;        class MatchAllOf final : public MatcherBase&lt;ArgT&gt; {            std::vector&lt;MatcherBase&lt;ArgT&gt; const*&gt; m_matchers;        public:            MatchAllOf() = default;            MatchAllOf(MatchAllOf const&amp;) = delete;            MatchAllOf&amp; operator=(MatchAllOf const&amp;) = delete;            MatchAllOf(MatchAllOf&amp;&amp;) = default;            MatchAllOf&amp; operator=(MatchAllOf&amp;&amp;) = default;            bool match( ArgT const&amp; arg ) const override {                for( auto matcher : m_matchers ) {                    if (!matcher-&gt;match(arg))                        return false;                }                return true;            }            std::string describe() const override {                std::string description;                description.reserve( 4 + m_matchers.size()*32 );                description += &quot;( &quot;;                bool first = true;                for( auto matcher : m_matchers ) {                    if( first )                        first = false;                    else                        description += &quot; and &quot;;                    description += matcher-&gt;toString();                }                description += &quot; )&quot;;                return description;            }            friend MatchAllOf operator&amp;&amp; (MatchAllOf&amp;&amp; lhs, MatcherBase&lt;ArgT&gt; const&amp; rhs) {                lhs.m_matchers.push_back(&amp;rhs);                return <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(lhs);            }            friend MatchAllOf operator&amp;&amp; (MatcherBase&lt;ArgT&gt; const&amp; lhs, MatchAllOf&amp;&amp; rhs) {                rhs.m_matchers.insert(rhs.m_matchers.begin(), &amp;lhs);                return <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(rhs);            }        };                        template&lt;typename ArgT&gt;        MatchAllOf&lt;ArgT&gt; operator&amp;&amp; (MatchAllOf&lt;ArgT&gt; const&amp; lhs, MatcherBase&lt;ArgT&gt; const&amp; rhs) = delete;                        template&lt;typename ArgT&gt;        MatchAllOf&lt;ArgT&gt; operator&amp;&amp; (MatcherBase&lt;ArgT&gt; const&amp; lhs, MatchAllOf&lt;ArgT&gt; const&amp; rhs) = delete;        template&lt;typename ArgT&gt;        class MatchAnyOf final : public MatcherBase&lt;ArgT&gt; {            std::vector&lt;MatcherBase&lt;ArgT&gt; const*&gt; m_matchers;        public:            MatchAnyOf() = default;            MatchAnyOf(MatchAnyOf const&amp;) = delete;            MatchAnyOf&amp; operator=(MatchAnyOf const&amp;) = delete;            MatchAnyOf(MatchAnyOf&amp;&amp;) = default;            MatchAnyOf&amp; operator=(MatchAnyOf&amp;&amp;) = default;            bool match( ArgT const&amp; arg ) const override {                for( auto matcher : m_matchers ) {                    if (matcher-&gt;match(arg))                        return true;                }                return false;            }            std::string describe() const override {                std::string description;                description.reserve( 4 + m_matchers.size()*32 );                description += &quot;( &quot;;                bool first = true;                for( auto matcher : m_matchers ) {                    if( first )                        first = false;                    else                        description += &quot; or &quot;;                    description += matcher-&gt;toString();                }                description += &quot; )&quot;;                return description;            }            friend MatchAnyOf operator|| (MatchAnyOf&amp;&amp; lhs, MatcherBase&lt;ArgT&gt; const&amp; rhs) {                lhs.m_matchers.push_back(&amp;rhs);                return <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(lhs);            }            friend MatchAnyOf operator|| (MatcherBase&lt;ArgT&gt; const&amp; lhs, MatchAnyOf&amp;&amp; rhs) {                rhs.m_matchers.insert(rhs.m_matchers.begin(), &amp;lhs);                return <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(rhs);            }        };                        template&lt;typename ArgT&gt;        MatchAnyOf&lt;ArgT&gt; operator|| (MatchAnyOf&lt;ArgT&gt; const&amp; lhs, MatcherBase&lt;ArgT&gt; const&amp; rhs) = delete;                        template&lt;typename ArgT&gt;        MatchAnyOf&lt;ArgT&gt; operator|| (MatcherBase&lt;ArgT&gt; const&amp; lhs, MatchAnyOf&lt;ArgT&gt; const&amp; rhs) = delete;        template&lt;typename ArgT&gt;        class MatchNotOf final : public MatcherBase&lt;ArgT&gt; {            MatcherBase&lt;ArgT&gt; const&amp; m_underlyingMatcher;        public:            explicit MatchNotOf( MatcherBase&lt;ArgT&gt; const&amp; underlyingMatcher ):                m_underlyingMatcher( underlyingMatcher )            {}            bool match( ArgT const&amp; arg ) const override {                return !m_underlyingMatcher.match( arg );            }            std::string describe() const override {                return &quot;not &quot; + m_underlyingMatcher.toString();            }        };    }     template &lt;typename T&gt;    Detail::MatchAllOf&lt;T&gt; operator&amp;&amp; (MatcherBase&lt;T&gt; const&amp; lhs, MatcherBase&lt;T&gt; const&amp; rhs) {        return Detail::MatchAllOf&lt;T&gt;{} &amp;&amp; lhs &amp;&amp; rhs;    }    template &lt;typename T&gt;    Detail::MatchAnyOf&lt;T&gt; operator|| (MatcherBase&lt;T&gt; const&amp; lhs, MatcherBase&lt;T&gt; const&amp; rhs) {        return Detail::MatchAnyOf&lt;T&gt;{} || lhs || rhs;    }    template &lt;typename T&gt;    Detail::MatchNotOf&lt;T&gt; operator! (MatcherBase&lt;T&gt; const&amp; matcher) {        return Detail::MatchNotOf&lt;T&gt;{ matcher };    }} } #if defined(CATCH_CONFIG_PREFIX_ALL) &amp;&amp; !defined(CATCH_CONFIG_DISABLE)  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )#elif defined(CATCH_CONFIG_PREFIX_ALL) &amp;&amp; defined(CATCH_CONFIG_DISABLE)  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)  #define CATCH_CHECK_THROWS_WITH( expr, matcher )                     (void)(0)  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)  #define CATCH_CHECK_THAT( arg, matcher )                             (void)(0)  #define CATCH_REQUIRE_THAT( arg, matcher )                           (void)(0)#elif !defined(CATCH_CONFIG_PREFIX_ALL) &amp;&amp; !defined(CATCH_CONFIG_DISABLE)  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )#elif !defined(CATCH_CONFIG_PREFIX_ALL) &amp;&amp; defined(CATCH_CONFIG_DISABLE)  #define REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)  #define CHECK_THROWS_WITH( expr, matcher )                     (void)(0)  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)  #define CHECK_THAT( arg, matcher )                             (void)(0)  #define REQUIRE_THAT( arg, matcher )                           (void)(0)#endif #endif #ifndef CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED#define CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED#ifndef CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED#define CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED#include &lt;array&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;type_traits&gt;namespace Catch {namespace Matchers {    class MatcherGenericBase : public MatcherUntypedBase {    public:        MatcherGenericBase() = default;        ~MatcherGenericBase() override;         MatcherGenericBase(MatcherGenericBase const&amp;) = default;        MatcherGenericBase(MatcherGenericBase&amp;&amp;) = default;        MatcherGenericBase&amp; operator=(MatcherGenericBase const&amp;) = delete;        MatcherGenericBase&amp; operator=(MatcherGenericBase&amp;&amp;) = delete;    };    namespace Detail {        template&lt;std::size_t N, std::size_t M&gt;        std::array&lt;void const*, N + M&gt; array_cat(std::array&lt;void const*, N&gt; &amp;&amp; lhs, std::array&lt;void const*, M&gt; &amp;&amp; rhs) {            std::array&lt;void const*, N + M&gt; arr{};            std::copy_n(lhs.begin(), N, arr.begin());            std::copy_n(rhs.begin(), M, arr.begin() + N);            return arr;        }        template&lt;std::size_t N&gt;        std::array&lt;void const*, N+1&gt; array_cat(std::array&lt;void const*, N&gt; &amp;&amp; lhs, void const* rhs) {            std::array&lt;void const*, N+1&gt; arr{};            std::copy_n(lhs.begin(), N, arr.begin());            arr[N] = rhs;            return arr;        }        template&lt;std::size_t N&gt;        std::array&lt;void const*, N+1&gt; array_cat(void const* lhs, std::array&lt;void const*, N&gt; &amp;&amp; rhs) {            std::array&lt;void const*, N + 1&gt; arr{ {lhs} };            std::copy_n(rhs.begin(), N, arr.begin() + 1);            return arr;        }        template&lt;typename T&gt;        static constexpr bool is_generic_matcher_v = std::is_base_of&lt;            Catch::Matchers::MatcherGenericBase,            std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;        &gt;::value;        template&lt;typename... Ts&gt;        static constexpr bool are_generic_matchers_v = <a class="el" href="structCatch_1_1Detail_1_1conjunction.html">Catch::Detail::conjunction</a>&lt;std::integral_constant&lt;bool,is_generic_matcher_v&lt;Ts&gt;&gt;...&gt;::value;        template&lt;typename T&gt;        static constexpr bool is_matcher_v = std::is_base_of&lt;            Catch::Matchers::MatcherUntypedBase,            std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;        &gt;::value;        template&lt;std::size_t N, typename Arg&gt;        bool match_all_of(Arg&amp;&amp;, std::array&lt;void const*, N&gt; const&amp;, std::index_sequence&lt;&gt;) {            return true;        }        template&lt;typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices&gt;        bool match_all_of(Arg&amp;&amp; arg, std::array&lt;void const*, N&gt; const&amp; matchers, std::index_sequence&lt;Idx, Indices...&gt;) {            return static_cast&lt;T const*&gt;(matchers[Idx])-&gt;match(arg) &amp;&amp; match_all_of&lt;MatcherTs...&gt;(arg, matchers, std::index_sequence&lt;Indices...&gt;{});        }        template&lt;std::size_t N, typename Arg&gt;        bool match_any_of(Arg&amp;&amp;, std::array&lt;void const*, N&gt; const&amp;, std::index_sequence&lt;&gt;) {            return false;        }        template&lt;typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices&gt;        bool match_any_of(Arg&amp;&amp; arg, std::array&lt;void const*, N&gt; const&amp; matchers, std::index_sequence&lt;Idx, Indices...&gt;) {            return static_cast&lt;T const*&gt;(matchers[Idx])-&gt;match(arg) || match_any_of&lt;MatcherTs...&gt;(arg, matchers, std::index_sequence&lt;Indices...&gt;{});        }        std::string describe_multi_matcher(StringRef combine, std::string const* descriptions_begin, std::string const* descriptions_end);        template&lt;typename... MatcherTs, std::size_t... Idx&gt;        std::string describe_multi_matcher(StringRef combine, std::array&lt;void const*, sizeof...(MatcherTs)&gt; const&amp; matchers, std::index_sequence&lt;Idx...&gt;) {            std::array&lt;std::string, sizeof...(MatcherTs)&gt; descriptions {{                static_cast&lt;MatcherTs const*&gt;(matchers[Idx])-&gt;toString()...            }};            return describe_multi_matcher(combine, descriptions.data(), descriptions.data() + descriptions.size());        }        template&lt;typename... MatcherTs&gt;        class MatchAllOfGeneric final : public MatcherGenericBase {        public:            MatchAllOfGeneric(MatchAllOfGeneric const&amp;) = delete;            MatchAllOfGeneric&amp; operator=(MatchAllOfGeneric const&amp;) = delete;            MatchAllOfGeneric(MatchAllOfGeneric&amp;&amp;) = default;            MatchAllOfGeneric&amp; operator=(MatchAllOfGeneric&amp;&amp;) = default;            MatchAllOfGeneric(MatcherTs const&amp;... matchers) : m_matchers{ {std::addressof(matchers)...} } {}            explicit MatchAllOfGeneric(std::array&lt;void const*, sizeof...(MatcherTs)&gt; matchers) : m_matchers{matchers} {}            template&lt;typename Arg&gt;            bool match(Arg&amp;&amp; arg) const {                return match_all_of&lt;MatcherTs...&gt;(arg, m_matchers, std::index_sequence_for&lt;MatcherTs...&gt;{});            }            std::string describe() const override {                return describe_multi_matcher&lt;MatcherTs...&gt;(&quot; and &quot;_sr, m_matchers, std::index_sequence_for&lt;MatcherTs...&gt;{});            }                                                std::array&lt;void const*, sizeof...( MatcherTs )&gt; m_matchers;                        template&lt;typename... MatchersRHS&gt;            friend            MatchAllOfGeneric&lt;MatcherTs..., MatchersRHS...&gt; operator &amp;&amp; (                    MatchAllOfGeneric&lt;MatcherTs...&gt;&amp;&amp; lhs,                    MatchAllOfGeneric&lt;MatchersRHS...&gt;&amp;&amp; rhs) {                return MatchAllOfGeneric&lt;MatcherTs..., MatchersRHS...&gt;{array_cat(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(lhs.m_matchers), <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(rhs.m_matchers))};            }                        template&lt;typename MatcherRHS&gt;            friend std::enable_if_t&lt;is_matcher_v&lt;MatcherRHS&gt;,            MatchAllOfGeneric&lt;MatcherTs..., MatcherRHS&gt;&gt; operator &amp;&amp; (                    MatchAllOfGeneric&lt;MatcherTs...&gt;&amp;&amp; lhs,                    MatcherRHS const&amp; rhs) {                return MatchAllOfGeneric&lt;MatcherTs..., MatcherRHS&gt;{array_cat(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(lhs.m_matchers), static_cast&lt;void const*&gt;(&amp;rhs))};            }                        template&lt;typename MatcherLHS&gt;            friend std::enable_if_t&lt;is_matcher_v&lt;MatcherLHS&gt;,            MatchAllOfGeneric&lt;MatcherLHS, MatcherTs...&gt;&gt; operator &amp;&amp; (                    MatcherLHS const&amp; lhs,                    MatchAllOfGeneric&lt;MatcherTs...&gt;&amp;&amp; rhs) {                return MatchAllOfGeneric&lt;MatcherLHS, MatcherTs...&gt;{array_cat(static_cast&lt;void const*&gt;(std::addressof(lhs)), <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(rhs.m_matchers))};            }        };        template&lt;typename... MatcherTs&gt;        class MatchAnyOfGeneric final : public MatcherGenericBase {        public:            MatchAnyOfGeneric(MatchAnyOfGeneric const&amp;) = delete;            MatchAnyOfGeneric&amp; operator=(MatchAnyOfGeneric const&amp;) = delete;            MatchAnyOfGeneric(MatchAnyOfGeneric&amp;&amp;) = default;            MatchAnyOfGeneric&amp; operator=(MatchAnyOfGeneric&amp;&amp;) = default;            MatchAnyOfGeneric(MatcherTs const&amp;... matchers) : m_matchers{ {std::addressof(matchers)...} } {}            explicit MatchAnyOfGeneric(std::array&lt;void const*, sizeof...(MatcherTs)&gt; matchers) : m_matchers{matchers} {}            template&lt;typename Arg&gt;            bool match(Arg&amp;&amp; arg) const {                return match_any_of&lt;MatcherTs...&gt;(arg, m_matchers, std::index_sequence_for&lt;MatcherTs...&gt;{});            }            std::string describe() const override {                return describe_multi_matcher&lt;MatcherTs...&gt;(&quot; or &quot;_sr, m_matchers, std::index_sequence_for&lt;MatcherTs...&gt;{});            }                                                std::array&lt;void const*, sizeof...( MatcherTs )&gt; m_matchers;                        template&lt;typename... MatchersRHS&gt;            friend MatchAnyOfGeneric&lt;MatcherTs..., MatchersRHS...&gt; operator || (                    MatchAnyOfGeneric&lt;MatcherTs...&gt;&amp;&amp; lhs,                    MatchAnyOfGeneric&lt;MatchersRHS...&gt;&amp;&amp; rhs) {                return MatchAnyOfGeneric&lt;MatcherTs..., MatchersRHS...&gt;{array_cat(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(lhs.m_matchers), <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(rhs.m_matchers))};            }                        template&lt;typename MatcherRHS&gt;            friend std::enable_if_t&lt;is_matcher_v&lt;MatcherRHS&gt;,            MatchAnyOfGeneric&lt;MatcherTs..., MatcherRHS&gt;&gt; operator || (                    MatchAnyOfGeneric&lt;MatcherTs...&gt;&amp;&amp; lhs,                    MatcherRHS const&amp; rhs) {                return MatchAnyOfGeneric&lt;MatcherTs..., MatcherRHS&gt;{array_cat(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(lhs.m_matchers), static_cast&lt;void const*&gt;(std::addressof(rhs)))};            }                        template&lt;typename MatcherLHS&gt;            friend std::enable_if_t&lt;is_matcher_v&lt;MatcherLHS&gt;,            MatchAnyOfGeneric&lt;MatcherLHS, MatcherTs...&gt;&gt; operator || (                MatcherLHS const&amp; lhs,                MatchAnyOfGeneric&lt;MatcherTs...&gt;&amp;&amp; rhs) {                return MatchAnyOfGeneric&lt;MatcherLHS, MatcherTs...&gt;{array_cat(static_cast&lt;void const*&gt;(std::addressof(lhs)), <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(rhs.m_matchers))};            }        };        template&lt;typename MatcherT&gt;        class MatchNotOfGeneric final : public MatcherGenericBase {            MatcherT const&amp; m_matcher;        public:            MatchNotOfGeneric(MatchNotOfGeneric const&amp;) = delete;            MatchNotOfGeneric&amp; operator=(MatchNotOfGeneric const&amp;) = delete;            MatchNotOfGeneric(MatchNotOfGeneric&amp;&amp;) = default;            MatchNotOfGeneric&amp; operator=(MatchNotOfGeneric&amp;&amp;) = default;            explicit MatchNotOfGeneric(MatcherT const&amp; matcher) : m_matcher{matcher} {}            template&lt;typename Arg&gt;            bool match(Arg&amp;&amp; arg) const {                return !m_matcher.match(arg);            }            std::string describe() const override {                return &quot;not &quot; + m_matcher.toString();            }                        friend MatcherT const&amp; operator ! (MatchNotOfGeneric&lt;MatcherT&gt; const&amp; matcher) {                return matcher.m_matcher;            }        };    }         template&lt;typename MatcherLHS, typename MatcherRHS&gt;    std::enable_if_t&lt;Detail::are_generic_matchers_v&lt;MatcherLHS, MatcherRHS&gt;, Detail::MatchAllOfGeneric&lt;MatcherLHS, MatcherRHS&gt;&gt;        operator &amp;&amp; (MatcherLHS const&amp; lhs, MatcherRHS const&amp; rhs) {        return { lhs, rhs };    }    template&lt;typename MatcherLHS, typename MatcherRHS&gt;    std::enable_if_t&lt;Detail::are_generic_matchers_v&lt;MatcherLHS, MatcherRHS&gt;, Detail::MatchAnyOfGeneric&lt;MatcherLHS, MatcherRHS&gt;&gt;        operator || (MatcherLHS const&amp; lhs, MatcherRHS const&amp; rhs) {        return { lhs, rhs };    }        template&lt;typename MatcherT&gt;    std::enable_if_t&lt;Detail::is_generic_matcher_v&lt;MatcherT&gt;, Detail::MatchNotOfGeneric&lt;MatcherT&gt;&gt;        operator ! (MatcherT const&amp; matcher) {        return Detail::MatchNotOfGeneric&lt;MatcherT&gt;{matcher};    }        template&lt;typename MatcherLHS, typename ArgRHS&gt;    std::enable_if_t&lt;Detail::is_generic_matcher_v&lt;MatcherLHS&gt;, Detail::MatchAllOfGeneric&lt;MatcherLHS, MatcherBase&lt;ArgRHS&gt;&gt;&gt;        operator &amp;&amp; (MatcherLHS const&amp; lhs, MatcherBase&lt;ArgRHS&gt; const&amp; rhs) {        return { lhs, rhs };    }    template&lt;typename ArgLHS, typename MatcherRHS&gt;    std::enable_if_t&lt;Detail::is_generic_matcher_v&lt;MatcherRHS&gt;, Detail::MatchAllOfGeneric&lt;MatcherBase&lt;ArgLHS&gt;, MatcherRHS&gt;&gt;        operator &amp;&amp; (MatcherBase&lt;ArgLHS&gt; const&amp; lhs, MatcherRHS const&amp; rhs) {        return { lhs, rhs };    }    template&lt;typename MatcherLHS, typename ArgRHS&gt;    std::enable_if_t&lt;Detail::is_generic_matcher_v&lt;MatcherLHS&gt;, Detail::MatchAnyOfGeneric&lt;MatcherLHS, MatcherBase&lt;ArgRHS&gt;&gt;&gt;        operator || (MatcherLHS const&amp; lhs, MatcherBase&lt;ArgRHS&gt; const&amp; rhs) {        return { lhs, rhs };    }    template&lt;typename ArgLHS, typename MatcherRHS&gt;    std::enable_if_t&lt;Detail::is_generic_matcher_v&lt;MatcherRHS&gt;, Detail::MatchAnyOfGeneric&lt;MatcherBase&lt;ArgLHS&gt;, MatcherRHS&gt;&gt;        operator || (MatcherBase&lt;ArgLHS&gt; const&amp; lhs, MatcherRHS const&amp; rhs) {        return { lhs, rhs };    }} } #endif namespace Catch {    namespace Matchers {        class IsEmptyMatcher final : public MatcherGenericBase {        public:            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::empty;#else                using std::empty;#endif                return empty(rng);            }            std::string describe() const override;        };        class HasSizeMatcher final : public MatcherGenericBase {            std::size_t m_target_size;        public:            explicit HasSizeMatcher(std::size_t target_size):                m_target_size(target_size)            {}            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::size;#else                using std::size;#endif                return size(rng) == m_target_size;            }            std::string describe() const override;        };        template &lt;typename Matcher&gt;        class SizeMatchesMatcher final : public MatcherGenericBase {            Matcher m_matcher;        public:            explicit SizeMatchesMatcher(Matcher m):                m_matcher(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(m))            {}            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::size;#else                using std::size;#endif                return m_matcher.match(size(rng));            }            std::string describe() const override {                return &quot;size matches &quot; + m_matcher.describe();            }        };                IsEmptyMatcher IsEmpty();                HasSizeMatcher SizeIs(std::size_t sz);        template &lt;typename Matcher&gt;        std::enable_if_t&lt;Detail::is_matcher_v&lt;Matcher&gt;,        SizeMatchesMatcher&lt;Matcher&gt;&gt; SizeIs(Matcher&amp;&amp; m) {            return SizeMatchesMatcher&lt;Matcher&gt;{<a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(m)};        }    } } #endif #ifndef CATCH_MATCHERS_CONTAINS_HPP_INCLUDED#define CATCH_MATCHERS_CONTAINS_HPP_INCLUDED#include &lt;functional&gt;#include &lt;type_traits&gt;namespace Catch {    namespace Matchers {                template &lt;typename T, typename Equality&gt;        class ContainsElementMatcher final : public MatcherGenericBase {            T m_desired;            Equality m_eq;        public:            template &lt;typename T2, typename Equality2&gt;            ContainsElementMatcher(T2&amp;&amp; target, Equality2&amp;&amp; predicate):                m_desired(<a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(target)),                m_eq(<a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(predicate))            {}            std::string describe() const override {                return &quot;contains element &quot; + Catch::Detail::stringify(m_desired);            }            template &lt;typename RangeLike&gt;            bool match( RangeLike&amp;&amp; rng ) const {                for ( auto&amp;&amp; elem : rng ) {                    if ( m_eq( elem, m_desired ) ) { return true; }                }                return false;            }        };                template &lt;typename Matcher&gt;        class ContainsMatcherMatcher final : public MatcherGenericBase {            Matcher m_matcher;        public:                                                ContainsMatcherMatcher(Matcher matcher):                m_matcher(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(matcher))            {}            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {                for (auto&amp;&amp; elem : rng) {                    if (m_matcher.match(elem)) {                        return true;                    }                }                return false;            }            std::string describe() const override {                return &quot;contains element matching &quot; + m_matcher.describe();            }        };                template &lt;typename T&gt;        std::enable_if_t&lt;!Detail::is_matcher_v&lt;T&gt;,        ContainsElementMatcher&lt;T, std::equal_to&lt;&gt;&gt;&gt; Contains(T&amp;&amp; elem) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(elem), std::equal_to&lt;&gt;{} };        }                template &lt;typename Matcher&gt;        std::enable_if_t&lt;Detail::is_matcher_v&lt;Matcher&gt;,        ContainsMatcherMatcher&lt;Matcher&gt;&gt; Contains(Matcher&amp;&amp; matcher) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(matcher) };        }                template &lt;typename T, typename Equality&gt;        ContainsElementMatcher&lt;T, Equality&gt; Contains(T&amp;&amp; elem, Equality&amp;&amp; eq) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(elem), <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(eq) };        }    }}#endif #ifndef CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED#define CATCH_MATCHERS_EXCEPTION_HPP_INCLUDEDnamespace Catch {namespace Matchers {class ExceptionMessageMatcher final : public MatcherBase&lt;std::exception&gt; {    std::string m_message;public:    ExceptionMessageMatcher(std::string const&amp; message):        m_message(message)    {}    bool match(std::exception const&amp; ex) const override;    std::string describe() const override;};ExceptionMessageMatcher Message(std::string const&amp; message);template &lt;typename StringMatcherType&gt;class ExceptionMessageMatchesMatcher final    : public MatcherBase&lt;std::exception&gt; {    StringMatcherType m_matcher;public:    ExceptionMessageMatchesMatcher( StringMatcherType matcher ):        m_matcher( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>( matcher ) ) {}    bool match( std::exception const&amp; ex ) const override {        return m_matcher.match( ex.what() );    }    std::string describe() const override {        return &quot; matches \&quot;&quot; + m_matcher.describe() + '&quot;';    }};template &lt;typename StringMatcherType&gt;ExceptionMessageMatchesMatcher&lt;StringMatcherType&gt;MessageMatches( StringMatcherType&amp;&amp; matcher ) {    return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( matcher ) };}} // namespace Matchers} // namespace Catch#endif // CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED#ifndef CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED#define CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDEDnamespace Catch {namespace Matchers {    namespace Detail {        enum class FloatingPointKind : uint8_t;    }    class  WithinAbsMatcher final : public MatcherBase&lt;double&gt; {    public:        WithinAbsMatcher(double target, double margin);        bool match(double const&amp; matchee) const override;        std::string describe() const override;    private:        double m_target;        double m_margin;    };        WithinAbsMatcher WithinAbs( double target, double margin );    class WithinUlpsMatcher final : public MatcherBase&lt;double&gt; {    public:        WithinUlpsMatcher( double target,                           uint64_t ulps,                           Detail::FloatingPointKind baseType );        bool match(double const&amp; matchee) const override;        std::string describe() const override;    private:        double m_target;        uint64_t m_ulps;        Detail::FloatingPointKind m_type;    };        WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);        WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);    // Given IEEE-754 format for floats and doubles, we can assume    // that float -&gt; double promotion is lossless. Given this, we can    // assume that if we do the standard relative comparison of    // |lhs - rhs| &lt;= epsilon * max(fabs(lhs), fabs(rhs)), then we get    // the same result if we do this for floats, as if we do this for    // doubles that were promoted from floats.    class WithinRelMatcher final : public MatcherBase&lt;double&gt; {    public:        WithinRelMatcher( double target, double epsilon );        bool match(double const&amp; matchee) const override;        std::string describe() const override;    private:        double m_target;        double m_epsilon;    };        WithinRelMatcher WithinRel(double target, double eps);        WithinRelMatcher WithinRel(double target);        WithinRelMatcher WithinRel(float target, float eps);        WithinRelMatcher WithinRel(float target);    class IsNaNMatcher final : public MatcherBase&lt;double&gt; {    public:        IsNaNMatcher() = default;        bool match( double const&amp; matchee ) const override;        std::string describe() const override;    };    IsNaNMatcher IsNaN();} // namespace Matchers} // namespace Catch#endif // CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED#ifndef CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#define CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#include &lt;string&gt;namespace Catch {namespace Matchers {namespace Detail {    std::string finalizeDescription(const std::string&amp; desc);} // namespace Detailtemplate &lt;typename T, typename Predicate&gt;class PredicateMatcher final : public MatcherBase&lt;T&gt; {    Predicate m_predicate;    std::string m_description;public:    PredicateMatcher(Predicate&amp;&amp; elem, std::string const&amp; descr)        :m_predicate(<a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(elem)),        m_description(Detail::finalizeDescription(descr))    {}    bool match( T const&amp; item ) const override {        return m_predicate(item);    }    std::string describe() const override {        return m_description;    }};    /**     * Creates a matcher that calls delegates `match` to the provided predicate.     *     * The user has to explicitly specify the argument type to the matcher     */    template&lt;typename T, typename Pred&gt;    PredicateMatcher&lt;T, Pred&gt; Predicate(Pred&amp;&amp; predicate, std::string const&amp; description = &quot;&quot;) {        static_assert(is_callable&lt;Pred(T)&gt;::value, &quot;Predicate not callable with argument T&quot;);        static_assert(std::is_same&lt;bool, FunctionReturnType&lt;Pred, T&gt;&gt;::value, &quot;Predicate does not return bool&quot;);        return PredicateMatcher&lt;T, Pred&gt;(<a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(predicate), description);    }} // namespace Matchers} // namespace Catch#endif // CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#ifndef CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED#define CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDEDnamespace Catch {    namespace Matchers {        // Matcher for checking that all elements in range matches a given matcher.        template &lt;typename Matcher&gt;        class AllMatchMatcher final : public MatcherGenericBase {            Matcher m_matcher;        public:            AllMatchMatcher(Matcher matcher):                m_matcher(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(matcher))            {}            std::string describe() const override {                return &quot;all match &quot; + m_matcher.describe();            }            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {                for (auto&amp;&amp; elem : rng) {                    if (!m_matcher.match(elem)) {                        return false;                    }                }                return true;            }        };        // Matcher for checking that no element in range matches a given matcher.        template &lt;typename Matcher&gt;        class NoneMatchMatcher final : public MatcherGenericBase {            Matcher m_matcher;        public:            NoneMatchMatcher(Matcher matcher):                m_matcher(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(matcher))            {}            std::string describe() const override {                return &quot;none match &quot; + m_matcher.describe();            }            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {                for (auto&amp;&amp; elem : rng) {                    if (m_matcher.match(elem)) {                        return false;                    }                }                return true;            }        };        // Matcher for checking that at least one element in range matches a given matcher.        template &lt;typename Matcher&gt;        class AnyMatchMatcher final : public MatcherGenericBase {            Matcher m_matcher;        public:            AnyMatchMatcher(Matcher matcher):                m_matcher(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(matcher))            {}            std::string describe() const override {                return &quot;any match &quot; + m_matcher.describe();            }            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {                for (auto&amp;&amp; elem : rng) {                    if (m_matcher.match(elem)) {                        return true;                    }                }                return false;            }        };        // Matcher for checking that all elements in range are true.        class AllTrueMatcher final : public MatcherGenericBase {        public:            std::string describe() const override;            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {                for (auto&amp;&amp; elem : rng) {                    if (!elem) {                        return false;                    }                }                return true;            }        };        // Matcher for checking that no element in range is true.        class NoneTrueMatcher final : public MatcherGenericBase {        public:            std::string describe() const override;            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {                for (auto&amp;&amp; elem : rng) {                    if (elem) {                        return false;                    }                }                return true;            }        };        // Matcher for checking that any element in range is true.        class AnyTrueMatcher final : public MatcherGenericBase {        public:            std::string describe() const override;            template &lt;typename RangeLike&gt;            bool match(RangeLike&amp;&amp; rng) const {                for (auto&amp;&amp; elem : rng) {                    if (elem) {                        return true;                    }                }                return false;            }        };        // Creates a matcher that checks whether all elements in a range match a matcher        template &lt;typename Matcher&gt;        AllMatchMatcher&lt;Matcher&gt; AllMatch(Matcher&amp;&amp; matcher) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(matcher) };        }        // Creates a matcher that checks whether no element in a range matches a matcher.        template &lt;typename Matcher&gt;        NoneMatchMatcher&lt;Matcher&gt; NoneMatch(Matcher&amp;&amp; matcher) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(matcher) };        }        // Creates a matcher that checks whether any element in a range matches a matcher.        template &lt;typename Matcher&gt;        AnyMatchMatcher&lt;Matcher&gt; AnyMatch(Matcher&amp;&amp; matcher) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>(matcher) };        }        // Creates a matcher that checks whether all elements in a range are true        AllTrueMatcher AllTrue();        // Creates a matcher that checks whether no element in a range is true        NoneTrueMatcher NoneTrue();        // Creates a matcher that checks whether any element in a range is true        AnyTrueMatcher AnyTrue();    }}#endif // CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED#ifndef CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#define CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#include &lt;functional&gt;namespace Catch {    namespace Matchers {        /**         * Matcher for checking that an element contains the same         * elements in the same order         */        template &lt;typename TargetRangeLike, typename Equality&gt;        class RangeEqualsMatcher final : public MatcherGenericBase {            TargetRangeLike m_desired;            Equality m_predicate;        public:            template &lt;typename TargetRangeLike2, typename Equality2&gt;            constexpr            RangeEqualsMatcher( TargetRangeLike2&amp;&amp; range,                                Equality2&amp;&amp; predicate ):                m_desired( <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( range ) ),                m_predicate( <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( predicate ) ) {}            template &lt;typename RangeLike&gt;            constexpr            bool match( RangeLike&amp;&amp; rng ) const {                auto rng_start = begin( rng );                const auto rng_end = end( rng );                auto target_start = begin( m_desired );                const auto target_end = end( m_desired );                while (rng_start != rng_end &amp;&amp; target_start != target_end) {                    if (!m_predicate(*rng_start, *target_start)) {                        return false;                    }                    ++rng_start;                    ++target_start;                }                return rng_start == rng_end &amp;&amp; target_start == target_end;            }            std::string describe() const override {                return &quot;elements are &quot; + Catch::Detail::stringify( m_desired );            }        };        /**         * Matcher for checking that an element contains the same         * elements (but not necessarily in the same order)         */        template &lt;typename TargetRangeLike, typename Equality&gt;        class UnorderedRangeEqualsMatcher final : public MatcherGenericBase {            TargetRangeLike m_desired;            Equality m_predicate;        public:            template &lt;typename TargetRangeLike2, typename Equality2&gt;            constexpr            UnorderedRangeEqualsMatcher( TargetRangeLike2&amp;&amp; range,                                         Equality2&amp;&amp; predicate ):                m_desired( <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( range ) ),                m_predicate( <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( predicate ) ) {}            template &lt;typename RangeLike&gt;            constexpr            bool match( RangeLike&amp;&amp; rng ) const {                using std::begin;                using std::end;                return <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Catch::Detail::is_permutation</a>( begin( m_desired ),                                                      end( m_desired ),                                                      begin( rng ),                                                      end( rng ),                                                      m_predicate );            }            std::string describe() const override {                return &quot;unordered elements are &quot; +                       ::Catch::Detail::stringify( m_desired );            }        };        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range.         *         * Uses the provided predicate `predicate` to do the comparisons         * (defaulting to `std::equal_to`)         */        template &lt;typename RangeLike,                  typename Equality = decltype( std::equal_to&lt;&gt;{} )&gt;        constexpr        RangeEqualsMatcher&lt;RangeLike, Equality&gt;        RangeEquals( RangeLike&amp;&amp; range,                     Equality&amp;&amp; predicate = std::equal_to&lt;&gt;{} ) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( range ), <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( predicate ) };        }        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in an initializer list.         *         * Uses the provided predicate `predicate` to do the comparisons         * (defaulting to `std::equal_to`)         */        template &lt;typename T,                  typename Equality = decltype( std::equal_to&lt;&gt;{} )&gt;        constexpr        RangeEqualsMatcher&lt;std::initializer_list&lt;T&gt;, Equality&gt;        RangeEquals( std::initializer_list&lt;T&gt; range,                     Equality&amp;&amp; predicate = std::equal_to&lt;&gt;{} ) {            return { range, <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( predicate ) };        }        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range, in some permutation.         *         * Uses the provided predicate `predicate` to do the comparisons         * (defaulting to `std::equal_to`)         */        template &lt;typename RangeLike,                  typename Equality = decltype( std::equal_to&lt;&gt;{} )&gt;        constexpr        UnorderedRangeEqualsMatcher&lt;RangeLike, Equality&gt;        UnorderedRangeEquals( RangeLike&amp;&amp; range,                              Equality&amp;&amp; predicate = std::equal_to&lt;&gt;{} ) {            return { <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( range ), <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( predicate ) };        }        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in an initializer list, in some permutation.         *         * Uses the provided predicate `predicate` to do the comparisons         * (defaulting to `std::equal_to`)         */        template &lt;typename T,                  typename Equality = decltype( std::equal_to&lt;&gt;{} )&gt;        constexpr        UnorderedRangeEqualsMatcher&lt;std::initializer_list&lt;T&gt;, Equality&gt;        UnorderedRangeEquals( std::initializer_list&lt;T&gt; range,                              Equality&amp;&amp; predicate = std::equal_to&lt;&gt;{} ) {            return { range, <a class="el" href="catch__amalgamated_8hpp.html#acedf14a4dca7fdf78bd48b59bc4d954a">CATCH_FORWARD</a>( predicate ) };        }    } // namespace Matchers} // namespace Catch#endif // CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#ifndef CATCH_MATCHERS_STRING_HPP_INCLUDED#define CATCH_MATCHERS_STRING_HPP_INCLUDED#include &lt;string&gt;namespace Catch {namespace Matchers {    struct CasedString {        CasedString( std::string const&amp; str, CaseSensitive caseSensitivity );        std::string adjustString( std::string const&amp; str ) const;        StringRef caseSensitivitySuffix() const;        CaseSensitive m_caseSensitivity;        std::string m_str;    };    class StringMatcherBase : public MatcherBase&lt;std::string&gt; {    protected:        CasedString m_comparator;        StringRef m_operation;    public:        StringMatcherBase( StringRef operation,                           CasedString const&amp; comparator );        std::string describe() const override;    };    class StringEqualsMatcher final : public StringMatcherBase {    public:        StringEqualsMatcher( CasedString const&amp; comparator );        bool match( std::string const&amp; source ) const override;    };    class StringContainsMatcher final : public StringMatcherBase {    public:        StringContainsMatcher( CasedString const&amp; comparator );        bool match( std::string const&amp; source ) const override;    };    class StartsWithMatcher final : public StringMatcherBase {    public:        StartsWithMatcher( CasedString const&amp; comparator );        bool match( std::string const&amp; source ) const override;    };    class EndsWithMatcher final : public StringMatcherBase {    public:        EndsWithMatcher( CasedString const&amp; comparator );        bool match( std::string const&amp; source ) const override;    };    class RegexMatcher final : public MatcherBase&lt;std::string&gt; {        std::string m_regex;        CaseSensitive m_caseSensitivity;    public:        RegexMatcher( std::string regex, CaseSensitive caseSensitivity );        bool match( std::string const&amp; matchee ) const override;        std::string describe() const override;    };        StringEqualsMatcher Equals( std::string const&amp; str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        StringContainsMatcher ContainsSubstring( std::string const&amp; str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        EndsWithMatcher EndsWith( std::string const&amp; str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        StartsWithMatcher StartsWith( std::string const&amp; str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        RegexMatcher Matches( std::string const&amp; regex, CaseSensitive caseSensitivity = CaseSensitive::Yes );} // namespace Matchers} // namespace Catch#endif // CATCH_MATCHERS_STRING_HPP_INCLUDED#ifndef CATCH_MATCHERS_VECTOR_HPP_INCLUDED#define CATCH_MATCHERS_VECTOR_HPP_INCLUDED#include &lt;algorithm&gt;namespace Catch {namespace Matchers {    template&lt;typename T, typename Alloc&gt;    class VectorContainsElementMatcher final : public MatcherBase&lt;std::vector&lt;T, Alloc&gt;&gt; {        T const&amp; m_comparator;    public:        VectorContainsElementMatcher(T const&amp; comparator):            m_comparator(comparator)        {}        bool match(std::vector&lt;T, Alloc&gt; const&amp; v) const override {            for (auto const&amp; el : v) {                if (el == m_comparator) {                    return true;                }            }            return false;        }        std::string describe() const override {            return &quot;Contains: &quot; + ::Catch::Detail::stringify( m_comparator );        }    };    template&lt;typename T, typename AllocComp, typename AllocMatch&gt;    class ContainsMatcher final : public MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {        std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;    public:        ContainsMatcher(std::vector&lt;T, AllocComp&gt; const&amp; comparator):            m_comparator( comparator )        {}        bool match(std::vector&lt;T, AllocMatch&gt; const&amp; v) const override {            // !TBD: see note in EqualsMatcher            if (m_comparator.size() &gt; v.size())                return false;            for (auto const&amp; comparator : m_comparator) {                auto present = false;                for (const auto&amp; el : v) {                    if (el == comparator) {                        present = true;                        break;                    }                }                if (!present) {                    return false;                }            }            return true;        }        std::string describe() const override {            return &quot;Contains: &quot; + ::Catch::Detail::stringify( m_comparator );        }    };    template&lt;typename T, typename AllocComp, typename AllocMatch&gt;    class EqualsMatcher final : public MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {        std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;    public:        EqualsMatcher(std::vector&lt;T, AllocComp&gt; const&amp; comparator):            m_comparator( comparator )        {}        bool match(std::vector&lt;T, AllocMatch&gt; const&amp; v) const override {            // !TBD: This currently works if all elements can be compared using !=            // - a more general approach would be via a compare template that defaults            // to using !=. but could be specialised for, e.g. std::vector&lt;T&gt; etc            // - then just call that directly            if ( m_comparator.size() != v.size() ) { return false; }            for ( std::size_t i = 0; i &lt; v.size(); ++i ) {                if ( !( m_comparator[i] == v[i] ) ) { return false; }            }            return true;        }        std::string describe() const override {            return &quot;Equals: &quot; + ::Catch::Detail::stringify( m_comparator );        }    };    template&lt;typename T, typename AllocComp, typename AllocMatch&gt;    class ApproxMatcher final : public MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {        std::vector&lt;T, AllocComp&gt; const&amp; m_comparator;        mutable <a class="el" href="classCatch_1_1Approx.html">Catch::Approx</a> approx = Catch::Approx::custom();    public:        ApproxMatcher(std::vector&lt;T, AllocComp&gt; const&amp; comparator):            m_comparator( comparator )        {}        bool match(std::vector&lt;T, AllocMatch&gt; const&amp; v) const override {            if (m_comparator.size() != v.size())                return false;            for (std::size_t i = 0; i &lt; v.size(); ++i)                if (m_comparator[i] != approx(v[i]))                    return false;            return true;        }        std::string describe() const override {            return &quot;is approx: &quot; + ::Catch::Detail::stringify( m_comparator );        }        template &lt;typename = std::enable_if_t&lt;std::is_constructible&lt;double, T&gt;::value&gt;&gt;        ApproxMatcher&amp; epsilon( T const&amp; newEpsilon ) {            approx.epsilon(static_cast&lt;double&gt;(newEpsilon));            return *this;        }        template &lt;typename = std::enable_if_t&lt;std::is_constructible&lt;double, T&gt;::value&gt;&gt;        ApproxMatcher&amp; margin( T const&amp; newMargin ) {            approx.margin(static_cast&lt;double&gt;(newMargin));            return *this;        }        template &lt;typename = std::enable_if_t&lt;std::is_constructible&lt;double, T&gt;::value&gt;&gt;        ApproxMatcher&amp; scale( T const&amp; newScale ) {            approx.scale(static_cast&lt;double&gt;(newScale));            return *this;        }    };    template&lt;typename T, typename AllocComp, typename AllocMatch&gt;    class UnorderedEqualsMatcher final : public MatcherBase&lt;std::vector&lt;T, AllocMatch&gt;&gt; {        std::vector&lt;T, AllocComp&gt; const&amp; m_target;    public:        UnorderedEqualsMatcher(std::vector&lt;T, AllocComp&gt; const&amp; target):            m_target(target)        {}        bool match(std::vector&lt;T, AllocMatch&gt; const&amp; vec) const override {            if (m_target.size() != vec.size()) {                return false;            }            return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());        }        std::string describe() const override {            return &quot;UnorderedEquals: &quot; + ::Catch::Detail::stringify(m_target);        }    };    // The following functions create the actual matcher objects.    // This allows the types to be inferred        template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;    ContainsMatcher&lt;T, AllocComp, AllocMatch&gt; Contains( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {        return ContainsMatcher&lt;T, AllocComp, AllocMatch&gt;(comparator);    }        template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;    VectorContainsElementMatcher&lt;T, Alloc&gt; VectorContains( T const&amp; comparator ) {        return VectorContainsElementMatcher&lt;T, Alloc&gt;(comparator);    }        template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;    EqualsMatcher&lt;T, AllocComp, AllocMatch&gt; Equals( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {        return EqualsMatcher&lt;T, AllocComp, AllocMatch&gt;(comparator);    }        template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;    ApproxMatcher&lt;T, AllocComp, AllocMatch&gt; Approx( std::vector&lt;T, AllocComp&gt; const&amp; comparator ) {        return ApproxMatcher&lt;T, AllocComp, AllocMatch&gt;(comparator);    }        template&lt;typename T, typename AllocComp = std::allocator&lt;T&gt;, typename AllocMatch = AllocComp&gt;    UnorderedEqualsMatcher&lt;T, AllocComp, AllocMatch&gt; UnorderedEquals(std::vector&lt;T, AllocComp&gt; const&amp; target) {        return UnorderedEqualsMatcher&lt;T, AllocComp, AllocMatch&gt;(target);    }} // namespace Matchers} // namespace Catch#endif // CATCH_MATCHERS_VECTOR_HPP_INCLUDED#endif // CATCH_MATCHERS_ALL_HPP_INCLUDED/** \file * This is a convenience header for Catch2's Reporter support. It includes * **all** of Catch2 headers related to reporters, including all reporters. * * Generally the Catch2 users should use specific includes they need, * but this header can be used instead for ease-of-experimentation, or * just plain convenience, at the cost of (significantly) increased * compilation times. * * When a new header (reporter) is added to either the `reporter` folder, * or to the corresponding internal subfolder, it should be added here. */#ifndef CATCH_REPORTERS_ALL_HPP_INCLUDED#define CATCH_REPORTERS_ALL_HPP_INCLUDED#ifndef CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#define CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#ifndef CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#define CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#ifndef CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#define CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#include &lt;map&gt;#include &lt;string&gt;namespace Catch {    class ColourImpl;    /**     * This is the base class for all reporters.     *     * If are writing a reporter, you must derive from this type, or one     * of the helper reporter bases that are derived from this type.     *     * ReporterBase centralizes handling of various common tasks in reporters,     * like storing the right stream for the reporters to write to, and     * providing the default implementation of the different listing events.     */    class ReporterBase : public IEventListener {    protected:                Detail::unique_ptr&lt;IStream&gt; m_wrapped_stream;                        std::ostream&amp; m_stream;                Detail::unique_ptr&lt;ColourImpl&gt; m_colour;                std::map&lt;std::string, std::string&gt; m_customOptions;    public:        ReporterBase( ReporterConfig&amp;&amp; config );        ~ReporterBase() override; // = default;        /**         * Provides a simple default listing of reporters.         *         * Should look roughly like the reporter listing in v2 and earlier         * versions of Catch2.         */        void listReporters(            std::vector&lt;ReporterDescription&gt; const&amp; descriptions ) override;        /**         * Provides a simple default listing of listeners         *         * Looks similarly to listing of reporters, but with listener type         * instead of reporter name.         */        void listListeners(            std::vector&lt;ListenerDescription&gt; const&amp; descriptions ) override;        /**         * Provides a simple default listing of tests.         *         * Should look roughly like the test listing in v2 and earlier versions         * of Catch2. Especially supports low-verbosity listing that mimics the         * old `--list-test-names-only` output.         */        void listTests( std::vector&lt;TestCaseHandle&gt; const&amp; tests ) override;        /**         * Provides a simple default listing of tags.         *         * Should look roughly like the tag listing in v2 and earlier versions         * of Catch2.         */        void listTags( std::vector&lt;TagInfo&gt; const&amp; tags ) override;    };} // namespace Catch#endif // CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#include &lt;vector&gt;namespace Catch {    class StreamingReporterBase : public ReporterBase {    public:        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        StreamingReporterBase(ReporterConfig&amp;&amp; _config):            ReporterBase(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(_config))        {}        ~StreamingReporterBase() override;        void benchmarkPreparing( StringRef ) override {}        void benchmarkStarting( BenchmarkInfo const&amp; ) override {}        void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; ) override {}        void benchmarkFailed( StringRef ) override {}        void fatalErrorEncountered( StringRef /*error*/ ) override {}        void noMatchingTestCases( StringRef /*unmatchedSpec*/ ) override {}        void reportInvalidTestSpec( StringRef /*invalidArgument*/ ) override {}        void testRunStarting( TestRunInfo const&amp; _testRunInfo ) override;        void testCaseStarting(TestCaseInfo const&amp; _testInfo) override  {            currentTestCaseInfo = &amp;_testInfo;        }        void testCasePartialStarting( TestCaseInfo const&amp;, uint64_t ) override {}        void sectionStarting(SectionInfo const&amp; _sectionInfo) override {            m_sectionStack.push_back(_sectionInfo);        }        void assertionStarting( AssertionInfo const&amp; ) override {}        void assertionEnded( AssertionStats const&amp; ) override {}        void sectionEnded(SectionStats const&amp; /* _sectionStats */) override {            m_sectionStack.pop_back();        }        void testCasePartialEnded( TestCaseStats const&amp;, uint64_t ) override {}        void testCaseEnded(TestCaseStats const&amp; /* _testCaseStats */) override {            currentTestCaseInfo = nullptr;        }        void testRunEnded( TestRunStats const&amp; /* _testRunStats */ ) override;        void skipTest(TestCaseInfo const&amp;) override {            // Don't do anything with this by default.            // It can optionally be overridden in the derived class.        }    protected:        TestRunInfo currentTestRunInfo{ &quot;test run has not started yet&quot;_sr };        TestCaseInfo const* currentTestCaseInfo = nullptr;                std::vector&lt;SectionInfo&gt; m_sectionStack;    };} // end namespace Catch#endif // CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#include &lt;string&gt;namespace Catch {    class AutomakeReporter final : public StreamingReporterBase {    public:        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        AutomakeReporter( ReporterConfig&amp;&amp; _config ):            StreamingReporterBase( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>( _config ) ) {            m_preferences.shouldReportAllAssertionStarts = false;        }        ~AutomakeReporter() override;        static std::string getDescription() {            using namespace std::string_literals;            return &quot;Reports test results in the format of Automake .trs files&quot;s;        }        void testCaseEnded(TestCaseStats const&amp; _testCaseStats) override;        void skipTest(TestCaseInfo const&amp; testInfo) override;    };} // end namespace Catch#endif // CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#ifndef CATCH_REPORTER_COMPACT_HPP_INCLUDED#define CATCH_REPORTER_COMPACT_HPP_INCLUDEDnamespace Catch {    class CompactReporter final : public StreamingReporterBase {    public:        CompactReporter( ReporterConfig&amp;&amp; _config ):            StreamingReporterBase( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>( _config ) ) {            m_preferences.shouldReportAllAssertionStarts = false;        }        ~CompactReporter() override;        static std::string getDescription();        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void testRunStarting( TestRunInfo const&amp; _testInfo ) override;        void assertionEnded(AssertionStats const&amp; _assertionStats) override;        void sectionEnded(SectionStats const&amp; _sectionStats) override;        void testRunEnded(TestRunStats const&amp; _testRunStats) override;    };} // end namespace Catch#endif // CATCH_REPORTER_COMPACT_HPP_INCLUDED#ifndef CATCH_REPORTER_CONSOLE_HPP_INCLUDED#define CATCH_REPORTER_CONSOLE_HPP_INCLUDEDnamespace Catch {    // Fwd decls    class TablePrinter;    class ConsoleReporter final : public StreamingReporterBase {        Detail::unique_ptr&lt;TablePrinter&gt; m_tablePrinter;    public:        ConsoleReporter(ReporterConfig&amp;&amp; config);        ~ConsoleReporter() override;        static std::string getDescription();        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void reportInvalidTestSpec( StringRef arg ) override;        void assertionEnded(AssertionStats const&amp; _assertionStats) override;        void sectionStarting(SectionInfo const&amp; _sectionInfo) override;        void sectionEnded(SectionStats const&amp; _sectionStats) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting(BenchmarkInfo const&amp; info) override;        void benchmarkEnded(BenchmarkStats&lt;&gt; const&amp; stats) override;        void benchmarkFailed( StringRef error ) override;        void testCaseEnded(TestCaseStats const&amp; _testCaseStats) override;        void testRunEnded(TestRunStats const&amp; _testRunStats) override;        void testRunStarting(TestRunInfo const&amp; _testRunInfo) override;    private:        void lazyPrint();        void lazyPrintWithoutClosingBenchmarkTable();        void lazyPrintRunInfo();        void printTestCaseAndSectionHeader();        void printClosedHeader(std::string const&amp; _name);        void printOpenHeader(std::string const&amp; _name);        // if string has a : in first line will set indent to follow it on        // subsequent lines        void printHeaderString(std::string const&amp; _string, std::size_t indent = 0);        void printTotalsDivider(Totals const&amp; totals);        bool m_headerPrinted = false;        bool m_testRunInfoPrinted = false;    };} // end namespace Catch#endif // CATCH_REPORTER_CONSOLE_HPP_INCLUDED#ifndef CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#define CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#include &lt;string&gt;#include &lt;vector&gt;namespace Catch {    namespace Detail {                class AssertionOrBenchmarkResult {            // This should really be a variant, but this is much faster            // to write and the data layout here is already terrible            // enough that we do not have to care about the object size.            Optional&lt;AssertionStats&gt; m_assertion;            Optional&lt;BenchmarkStats&lt;&gt;&gt; m_benchmark;        public:            AssertionOrBenchmarkResult(AssertionStats const&amp; assertion);            AssertionOrBenchmarkResult(BenchmarkStats&lt;&gt; const&amp; benchmark);            bool isAssertion() const;            bool isBenchmark() const;            AssertionStats const&amp; asAssertion() const;            BenchmarkStats&lt;&gt; const&amp; asBenchmark() const;        };    }    /**     * Utility base for reporters that need to handle all results at once     *     * It stores tree of all test cases, sections and assertions, and after the     * test run is finished, calls into `testRunEndedCumulative` to pass the     * control to the deriving class.     *     * If you are deriving from this class and override any testing related     * member functions, you should first call into the base's implementation to     * avoid breaking the tree construction.     *     * Due to the way this base functions, it has to expand assertions up-front,     * even if they are later unused (e.g. because the deriving reporter does     * not report successful assertions, or because the deriving reporter does     * not use assertion expansion at all). Derived classes can use two     * customization points, `m_shouldStoreSuccesfulAssertions` and     * `m_shouldStoreFailedAssertions`, to disable the expansion and gain extra     * performance. **Accessing the assertion expansions if it wasn't stored is     * UB.**     */    class CumulativeReporterBase : public ReporterBase {    public:        template&lt;typename T, typename ChildNodeT&gt;        struct Node {            explicit Node( T const&amp; _value ) : value( _value ) {}            using ChildNodes = std::vector&lt;Detail::unique_ptr&lt;ChildNodeT&gt;&gt;;            T value;            ChildNodes children;        };        struct SectionNode {            explicit SectionNode(SectionStats const&amp; _stats) : stats(_stats) {}            bool operator == (SectionNode const&amp; other) const {                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;            }            bool hasAnyAssertions() const;            SectionStats stats;            std::vector&lt;Detail::unique_ptr&lt;SectionNode&gt;&gt; childSections;            std::vector&lt;Detail::AssertionOrBenchmarkResult&gt; assertionsAndBenchmarks;            std::string stdOut;            std::string stdErr;        };        using TestCaseNode = Node&lt;TestCaseStats, SectionNode&gt;;        using TestRunNode = Node&lt;TestRunStats, TestCaseNode&gt;;        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        CumulativeReporterBase(ReporterConfig&amp;&amp; _config):            ReporterBase(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(_config))        {}        ~CumulativeReporterBase() override;        void benchmarkPreparing( StringRef ) override {}        void benchmarkStarting( BenchmarkInfo const&amp; ) override {}        void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;        void benchmarkFailed( StringRef ) override {}        void noMatchingTestCases( StringRef ) override {}        void reportInvalidTestSpec( StringRef ) override {}        void fatalErrorEncountered( StringRef /*error*/ ) override {}        void testRunStarting( TestRunInfo const&amp; ) override {}        void testCaseStarting( TestCaseInfo const&amp; ) override {}        void testCasePartialStarting( TestCaseInfo const&amp;, uint64_t ) override {}        void sectionStarting( SectionInfo const&amp; sectionInfo ) override;        void assertionStarting( AssertionInfo const&amp; ) override {}        void assertionEnded( AssertionStats const&amp; assertionStats ) override;        void sectionEnded( SectionStats const&amp; sectionStats ) override;        void testCasePartialEnded( TestCaseStats const&amp;, uint64_t ) override {}        void testCaseEnded( TestCaseStats const&amp; testCaseStats ) override;        void testRunEnded( TestRunStats const&amp; testRunStats ) override;                virtual void testRunEndedCumulative() = 0;        void skipTest(TestCaseInfo const&amp;) override {}    protected:                bool m_shouldStoreSuccesfulAssertions = true;                bool m_shouldStoreFailedAssertions = true;        // We need lazy construction here. We should probably refactor it        // later, after the events are redone.                Detail::unique_ptr&lt;TestRunNode&gt; m_testRun;    private:        // Note: We rely on pointer identity being stable, which is why        //       we store pointers to the nodes rather than the values.        std::vector&lt;Detail::unique_ptr&lt;TestCaseNode&gt;&gt; m_testCases;        // Root section of the _current_ test case        Detail::unique_ptr&lt;SectionNode&gt; m_rootSection;        // Deepest section of the _current_ test case        SectionNode* m_deepestSection = nullptr;        // Stack of _active_ sections in the _current_ test case        std::vector&lt;SectionNode*&gt; m_sectionStack;    };} // end namespace Catch#endif // CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#ifndef CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED#define CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDEDnamespace Catch {    /**     * Base class to simplify implementing listeners.     *     * Provides empty default implementation for all IEventListener member     * functions, so that a listener implementation can pick which     * member functions it actually cares about.     */    class EventListenerBase : public IEventListener {    public:        using IEventListener::IEventListener;        void reportInvalidTestSpec( StringRef unmatchedSpec ) override;        void fatalErrorEncountered( StringRef error ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) override;        void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;        void benchmarkFailed( StringRef error ) override;        void assertionStarting( AssertionInfo const&amp; assertionInfo ) override;        void assertionEnded( AssertionStats const&amp; assertionStats ) override;        void listReporters(            std::vector&lt;ReporterDescription&gt; const&amp; descriptions ) override;        void listListeners(            std::vector&lt;ListenerDescription&gt; const&amp; descriptions ) override;        void listTests( std::vector&lt;TestCaseHandle&gt; const&amp; tests ) override;        void listTags( std::vector&lt;TagInfo&gt; const&amp; tagInfos ) override;        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void testRunStarting( TestRunInfo const&amp; testRunInfo ) override;        void testCaseStarting( TestCaseInfo const&amp; testInfo ) override;        void testCasePartialStarting( TestCaseInfo const&amp; testInfo,                                      uint64_t partNumber ) override;        void sectionStarting( SectionInfo const&amp; sectionInfo ) override;        void sectionEnded( SectionStats const&amp; sectionStats ) override;        void testCasePartialEnded( TestCaseStats const&amp; testCaseStats,                                   uint64_t partNumber ) override;        void testCaseEnded( TestCaseStats const&amp; testCaseStats ) override;        void testRunEnded( TestRunStats const&amp; testRunStats ) override;        void skipTest( TestCaseInfo const&amp; testInfo ) override;    };} // end namespace Catch#endif // CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED#ifndef CATCH_REPORTER_HELPERS_HPP_INCLUDED#define CATCH_REPORTER_HELPERS_HPP_INCLUDED#include &lt;iosfwd&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace Catch {    class IConfig;    class TestCaseHandle;    class ColourImpl;    // Returns double formatted as %.3f (format expected on output)    std::string getFormattedDuration( double duration );        bool shouldShowDuration( IConfig const&amp; config, double duration );    std::string serializeFilters( std::vector&lt;std::string&gt; const&amp; filters );    struct lineOfChars {        char c;        constexpr lineOfChars( char c_ ): c( c_ ) {}        friend std::ostream&amp; operator&lt;&lt;( std::ostream&amp; out, lineOfChars value );    };    /**     * Lists reporter descriptions to the provided stream in user-friendly     * format     *     * Used as the default listing implementation by the first party reporter     * bases. The output should be backwards compatible with the output of     * Catch2 v2 binaries.     */    void    defaultListReporters( std::ostream&amp; out,                          std::vector&lt;ReporterDescription&gt; const&amp; descriptions,                          Verbosity verbosity );    /**     * Lists listeners descriptions to the provided stream in user-friendly     * format     */    void defaultListListeners( std::ostream&amp; out,                               std::vector&lt;ListenerDescription&gt; const&amp; descriptions );    /**     * Lists tag information to the provided stream in user-friendly format     *     * Used as the default listing implementation by the first party reporter     * bases. The output should be backwards compatible with the output of     * Catch2 v2 binaries.     */    void defaultListTags( std::ostream&amp; out, std::vector&lt;TagInfo&gt; const&amp; tags, bool isFiltered );    /**     * Lists test case information to the provided stream in user-friendly     * format     *     * Used as the default listing implementation by the first party reporter     * bases. The output is backwards compatible with the output of Catch2     * v2 binaries, and also supports the format specific to the old     * `--list-test-names-only` option, for people who used it in integrations.     */    void defaultListTests( std::ostream&amp; out,                           ColourImpl* streamColour,                           std::vector&lt;TestCaseHandle&gt; const&amp; tests,                           bool isFiltered,                           Verbosity verbosity );    /**     * Prints test run totals to the provided stream in user-friendly format     *     * Used by the console and compact reporters.     */    void printTestRunTotals( std::ostream&amp; stream,                      ColourImpl&amp; streamColour,                      Totals const&amp; totals );} // end namespace Catch#endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED#ifndef CATCH_REPORTER_JSON_HPP_INCLUDED#define CATCH_REPORTER_JSON_HPP_INCLUDED#include &lt;stack&gt;namespace Catch {    class JsonReporter : public StreamingReporterBase {    public:        JsonReporter( ReporterConfig&amp;&amp; config );        ~JsonReporter() override;        static std::string getDescription();    public: // StreamingReporterBase        void testRunStarting( TestRunInfo const&amp; runInfo ) override;        void testRunEnded( TestRunStats const&amp; runStats ) override;        void testCaseStarting( TestCaseInfo const&amp; tcInfo ) override;        void testCaseEnded( TestCaseStats const&amp; tcStats ) override;        void testCasePartialStarting( TestCaseInfo const&amp; tcInfo,                                      uint64_t index ) override;        void testCasePartialEnded( TestCaseStats const&amp; tcStats,                                   uint64_t index ) override;        void sectionStarting( SectionInfo const&amp; sectionInfo ) override;        void sectionEnded( SectionStats const&amp; sectionStats ) override;        void assertionEnded( AssertionStats const&amp; assertionStats ) override;        //void testRunEndedCumulative() override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const&amp; ) override;        void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; ) override;        void benchmarkFailed( StringRef error ) override;        void listReporters(            std::vector&lt;ReporterDescription&gt; const&amp; descriptions ) override;        void listListeners(            std::vector&lt;ListenerDescription&gt; const&amp; descriptions ) override;        void listTests( std::vector&lt;TestCaseHandle&gt; const&amp; tests ) override;        void listTags( std::vector&lt;TagInfo&gt; const&amp; tags ) override;    private:        Timer m_testCaseTimer;        enum class Writer {            Object,            Array        };        JsonArrayWriter&amp; startArray();        JsonArrayWriter&amp; startArray( StringRef key );        JsonObjectWriter&amp; startObject();        JsonObjectWriter&amp; startObject( StringRef key );        void endObject();        void endArray();        bool isInside( Writer writer );        void startListing();        void endListing();        // Invariant:        // When m_writers is not empty and its top element is        // - Writer::Object, then m_objectWriters is not be empty        // - Writer::Array,  then m_arrayWriters shall not be empty        std::stack&lt;JsonObjectWriter&gt; m_objectWriters{};        std::stack&lt;JsonArrayWriter&gt; m_arrayWriters{};        std::stack&lt;Writer&gt; m_writers{};        bool m_startedListing = false;        // std::size_t m_sectionDepth = 0;        // std::size_t m_sectionStarted = 0;    };} // namespace Catch#endif // CATCH_REPORTER_JSON_HPP_INCLUDED#ifndef CATCH_REPORTER_JUNIT_HPP_INCLUDED#define CATCH_REPORTER_JUNIT_HPP_INCLUDEDnamespace Catch {    class JunitReporter final : public CumulativeReporterBase {    public:        JunitReporter(ReporterConfig&amp;&amp; _config);        static std::string getDescription();        void testRunStarting(TestRunInfo const&amp; runInfo) override;        void testCaseStarting(TestCaseInfo const&amp; testCaseInfo) override;        void assertionEnded(AssertionStats const&amp; assertionStats) override;        void testCaseEnded(TestCaseStats const&amp; testCaseStats) override;        void testRunEndedCumulative() override;    private:        void writeRun(TestRunNode const&amp; testRunNode, double suiteTime);        void writeTestCase(TestCaseNode const&amp; testCaseNode);        void writeSection( std::string const&amp; className,                           std::string const&amp; rootName,                           SectionNode const&amp; sectionNode,                           bool testOkToFail );        void writeAssertions(SectionNode const&amp; sectionNode);        void writeAssertion(AssertionStats const&amp; stats);        XmlWriter xml;        Timer suiteTimer;        std::string stdOutForSuite;        std::string stdErrForSuite;        unsigned int unexpectedExceptions = 0;        bool m_okToFail = false;    };} // end namespace Catch#endif // CATCH_REPORTER_JUNIT_HPP_INCLUDED#ifndef CATCH_REPORTER_MULTI_HPP_INCLUDED#define CATCH_REPORTER_MULTI_HPP_INCLUDEDnamespace Catch {    class MultiReporter final : public IEventListener {        /*         * Stores all added reporters and listeners         *         * All Listeners are stored before all reporters, and individual         * listeners/reporters are stored in order of insertion.         */        std::vector&lt;IEventListenerPtr&gt; m_reporterLikes;        bool m_haveNoncapturingReporters = false;        // Keep track of how many listeners we have already inserted,        // so that we can insert them into the main vector at the right place        size_t m_insertedListeners = 0;        void updatePreferences(IEventListener const&amp; reporterish);    public:        MultiReporter( IConfig const* config ):            IEventListener( config ) {            m_preferences.shouldReportAllAssertionStarts = false;        }        using IEventListener::IEventListener;        void addListener( IEventListenerPtr&amp;&amp; listener );        void addReporter( IEventListenerPtr&amp;&amp; reporter );    public: // IEventListener        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void fatalErrorEncountered( StringRef error ) override;        void reportInvalidTestSpec( StringRef arg ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) override;        void benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;        void benchmarkFailed( StringRef error ) override;        void testRunStarting( TestRunInfo const&amp; testRunInfo ) override;        void testCaseStarting( TestCaseInfo const&amp; testInfo ) override;        void testCasePartialStarting(TestCaseInfo const&amp; testInfo, uint64_t partNumber) override;        void sectionStarting( SectionInfo const&amp; sectionInfo ) override;        void assertionStarting( AssertionInfo const&amp; assertionInfo ) override;        void assertionEnded( AssertionStats const&amp; assertionStats ) override;        void sectionEnded( SectionStats const&amp; sectionStats ) override;        void testCasePartialEnded(TestCaseStats const&amp; testStats, uint64_t partNumber) override;        void testCaseEnded( TestCaseStats const&amp; testCaseStats ) override;        void testRunEnded( TestRunStats const&amp; testRunStats ) override;        void skipTest( TestCaseInfo const&amp; testInfo ) override;        void listReporters(std::vector&lt;ReporterDescription&gt; const&amp; descriptions) override;        void listListeners(std::vector&lt;ListenerDescription&gt; const&amp; descriptions) override;        void listTests(std::vector&lt;TestCaseHandle&gt; const&amp; tests) override;        void listTags(std::vector&lt;TagInfo&gt; const&amp; tags) override;    };} // end namespace Catch#endif // CATCH_REPORTER_MULTI_HPP_INCLUDED#ifndef CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#include &lt;type_traits&gt;namespace Catch {    namespace Detail {        template &lt;typename T, typename = void&gt;        struct has_description : std::false_type {};        template &lt;typename T&gt;        struct has_description&lt;            T,            void_t&lt;decltype( T::getDescription() )&gt;&gt;            : std::true_type {};                        void registerReporterImpl( std::string const&amp; name,                                   IReporterFactoryPtr reporterPtr );                void registerListenerImpl( Detail::unique_ptr&lt;EventListenerFactory&gt; listenerFactory );    } // namespace Detail    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr&lt;IEventListener&gt;;    template &lt;typename T&gt;    class ReporterFactory : public IReporterFactory {        IEventListenerPtr create( ReporterConfig&amp;&amp; config ) const override {            return Detail::make_unique&lt;T&gt;( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(config) );        }        std::string getDescription() const override {            return T::getDescription();        }    };    template&lt;typename T&gt;    class ReporterRegistrar {    public:        explicit ReporterRegistrar( std::string const&amp; name ) {            registerReporterImpl( name,                                  Detail::make_unique&lt;ReporterFactory&lt;T&gt;&gt;() );        }    };    template&lt;typename T&gt;    class ListenerRegistrar {        class TypedListenerFactory : public EventListenerFactory {            StringRef m_listenerName;            std::string getDescriptionImpl( std::true_type ) const {                return T::getDescription();            }            std::string getDescriptionImpl( std::false_type ) const {                return &quot;(No description provided)&quot;;            }        public:            TypedListenerFactory( StringRef listenerName ):                m_listenerName( listenerName ) {}            IEventListenerPtr create( IConfig const* config ) const override {                return Detail::make_unique&lt;T&gt;( config );            }            StringRef getName() const override {                return m_listenerName;            }            std::string getDescription() const override {                return getDescriptionImpl( Detail::has_description&lt;T&gt;{} );            }        };    public:        ListenerRegistrar(StringRef listenerName) {            registerListenerImpl( Detail::make_unique&lt;TypedListenerFactory&gt;(listenerName) );        }    };}#if !defined(CATCH_CONFIG_DISABLE)#    define CATCH_REGISTER_REPORTER( name, reporterType )                  \        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \        namespace {                                                        \            const Catch::ReporterRegistrar&lt;reporterType&gt;                   \                INTERNAL_CATCH_UNIQUE_NAME( catch_internal_RegistrarFor )( \                    name );                                                \        }                                                                  \        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION#    define CATCH_REGISTER_LISTENER( listenerType )                        \        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \        namespace {                                                        \            const Catch::ListenerRegistrar&lt;listenerType&gt;                   \                INTERNAL_CATCH_UNIQUE_NAME( catch_internal_RegistrarFor )( \                    #listenerType##_catch_sr );                            \        }                                                                  \        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION#else // CATCH_CONFIG_DISABLE#define CATCH_REGISTER_REPORTER(name, reporterType)#define CATCH_REGISTER_LISTENER(listenerType)#endif // CATCH_CONFIG_DISABLE#endif // CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#ifndef CATCH_REPORTER_SONARQUBE_HPP_INCLUDED#define CATCH_REPORTER_SONARQUBE_HPP_INCLUDEDnamespace Catch {    class SonarQubeReporter final : public CumulativeReporterBase {    public:        SonarQubeReporter(ReporterConfig&amp;&amp; config)        : CumulativeReporterBase(<a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(config))        , xml(m_stream) {            m_preferences.shouldRedirectStdOut = true;            m_preferences.shouldReportAllAssertions = false;            m_preferences.shouldReportAllAssertionStarts = false;            m_shouldStoreSuccesfulAssertions = false;        }        static std::string getDescription() {            using namespace std::string_literals;            return &quot;Reports test results in the Generic Test Data SonarQube XML format&quot;s;        }        void testRunStarting( TestRunInfo const&amp; testRunInfo ) override;        void testRunEndedCumulative() override {            writeRun( *m_testRun );            xml.endElement();        }        void writeRun( TestRunNode const&amp; runNode );        void writeTestFile(StringRef filename, std::vector&lt;TestCaseNode const*&gt; const&amp; testCaseNodes);        void writeTestCase(TestCaseNode const&amp; testCaseNode);        void writeSection(std::string const&amp; rootName, SectionNode const&amp; sectionNode, bool okToFail);        void writeAssertions(SectionNode const&amp; sectionNode, bool okToFail);        void writeAssertion(AssertionStats const&amp; stats, bool okToFail);    private:        XmlWriter xml;    };} // end namespace Catch#endif // CATCH_REPORTER_SONARQUBE_HPP_INCLUDED#ifndef CATCH_REPORTER_TAP_HPP_INCLUDED#define CATCH_REPORTER_TAP_HPP_INCLUDEDnamespace Catch {    class TAPReporter final : public StreamingReporterBase {    public:        TAPReporter( ReporterConfig&amp;&amp; config ):            StreamingReporterBase( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(config) ) {            m_preferences.shouldReportAllAssertions = true;            m_preferences.shouldReportAllAssertionStarts = false;        }        static std::string getDescription() {            using namespace std::string_literals;            return &quot;Reports test results in TAP format, suitable for test harnesses&quot;s;        }        void testRunStarting( TestRunInfo const&amp; testInfo ) override;        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void assertionEnded(AssertionStats const&amp; _assertionStats) override;        void testRunEnded(TestRunStats const&amp; _testRunStats) override;    private:        std::size_t counter = 0;    };} // end namespace Catch#endif // CATCH_REPORTER_TAP_HPP_INCLUDED#ifndef CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#define CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#include &lt;cstring&gt;#ifdef __clang__#   pragma clang diagnostic push#   pragma clang diagnostic ignored &quot;-Wpadded&quot;#endifnamespace Catch {    class TeamCityReporter final : public StreamingReporterBase {    public:        TeamCityReporter( ReporterConfig&amp;&amp; _config )        :   StreamingReporterBase( <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(_config) )        {            m_preferences.shouldRedirectStdOut = true;            m_preferences.shouldReportAllAssertionStarts = false;        }        ~TeamCityReporter() override;        static std::string getDescription() {            using namespace std::string_literals;            return &quot;Reports test results as TeamCity service messages&quot;s;        }        void testRunStarting( TestRunInfo const&amp; runInfo ) override;        void testRunEnded( TestRunStats const&amp; runStats ) override;        void assertionEnded(AssertionStats const&amp; assertionStats) override;        void sectionStarting(SectionInfo const&amp; sectionInfo) override {            m_headerPrintedForThisSection = false;            StreamingReporterBase::sectionStarting( sectionInfo );        }        void testCaseStarting(TestCaseInfo const&amp; testInfo) override;        void testCaseEnded(TestCaseStats const&amp; testCaseStats) override;    private:        void printSectionHeader(std::ostream&amp; os);        bool m_headerPrintedForThisSection = false;        Timer m_testTimer;    };} // end namespace Catch#ifdef __clang__#   pragma clang diagnostic pop#endif#endif // CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#ifndef CATCH_REPORTER_XML_HPP_INCLUDED#define CATCH_REPORTER_XML_HPP_INCLUDEDnamespace Catch {    class XmlReporter : public StreamingReporterBase {    public:        XmlReporter(ReporterConfig&amp;&amp; _config);        ~XmlReporter() override;        static std::string getDescription();        virtual std::string getStylesheetRef() const;        void writeSourceInfo(SourceLineInfo const&amp; sourceInfo);    public: // StreamingReporterBase        void testRunStarting(TestRunInfo const&amp; testInfo) override;        void testCaseStarting(TestCaseInfo const&amp; testInfo) override;        void sectionStarting(SectionInfo const&amp; sectionInfo) override;        void assertionEnded(AssertionStats const&amp; assertionStats) override;        void sectionEnded(SectionStats const&amp; sectionStats) override;        void testCaseEnded(TestCaseStats const&amp; testCaseStats) override;        void testRunEnded(TestRunStats const&amp; testRunStats) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting(BenchmarkInfo const&amp;) override;        void benchmarkEnded(BenchmarkStats&lt;&gt; const&amp;) override;        void benchmarkFailed( StringRef error ) override;        void listReporters(std::vector&lt;ReporterDescription&gt; const&amp; descriptions) override;        void listListeners(std::vector&lt;ListenerDescription&gt; const&amp; descriptions) override;        void listTests(std::vector&lt;TestCaseHandle&gt; const&amp; tests) override;        void listTags(std::vector&lt;TagInfo&gt; const&amp; tags) override;    private:        Timer m_testCaseTimer;        XmlWriter m_xml;        int m_sectionDepth = 0;    };} // end namespace Catch#endif // CATCH_REPORTER_XML_HPP_INCLUDED#endif // CATCH_REPORTERS_ALL_HPP_INCLUDED#endif // CATCH_ALL_HPP_INCLUDED#endif // CATCH_AMALGAMATED_HPP_INCLUDED#ifndef CATCH_WINDOWS_H_PROXY_HPP_INCLUDED#define CATCH_WINDOWS_H_PROXY_HPP_INCLUDED#if defined(CATCH_PLATFORM_WINDOWS)// We might end up with the define made globally through the compiler,// and we don't want to trigger warnings for this#if !defined(NOMINMAX)#  define NOMINMAX#endif#if !defined(WIN32_LEAN_AND_MEAN)#  define WIN32_LEAN_AND_MEAN#endif#include &lt;windows.h&gt;#endif // defined(CATCH_PLATFORM_WINDOWS)#endif // CATCH_WINDOWS_H_PROXY_HPP_INCLUDEDnamespace Catch {    namespace Benchmark {        namespace Detail {            ChronometerConcept::~ChronometerConcept() = default;        } // namespace Detail    } // namespace Benchmark} // namespace Catch// Adapted from donated nonius code.#include &lt;vector&gt;namespace Catch {    namespace Benchmark {        namespace Detail {            SampleAnalysis analyse(const IConfig &amp;cfg, FDuration* first, FDuration* last) {                if (!cfg.benchmarkNoAnalysis()) {                    std::vector&lt;double&gt; samples;                    samples.reserve(static_cast&lt;size_t&gt;(last - first));                    for (auto current = first; current != last; ++current) {                        samples.push_back( current-&gt;count() );                    }                    auto analysis = Catch::Benchmark::Detail::analyse_samples(                        cfg.benchmarkConfidenceInterval(),                        cfg.benchmarkResamples(),                        samples.data(),                        samples.data() + samples.size() );                    auto outliers = Catch::Benchmark::Detail::classify_outliers(                        samples.data(), samples.data() + samples.size() );                    auto wrap_estimate = [](Estimate&lt;double&gt; e) {                        return Estimate&lt;FDuration&gt; {                            FDuration(e.point),                                FDuration(e.lower_bound),                                FDuration(e.upper_bound),                                e.confidence_interval,                        };                    };                    std::vector&lt;FDuration&gt; samples2;                    samples2.reserve(samples.size());                    for (auto s : samples) {                        samples2.push_back( FDuration( s ) );                    }                    return {                        <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(samples2),                        wrap_estimate(analysis.mean),                        wrap_estimate(analysis.standard_deviation),                        outliers,                        analysis.outlier_variance,                    };                } else {                    std::vector&lt;FDuration&gt; samples;                    samples.reserve(static_cast&lt;size_t&gt;(last - first));                    FDuration mean = FDuration(0);                    int i = 0;                    for (auto it = first; it &lt; last; ++it, ++i) {                        samples.push_back(*it);                        mean += *it;                    }                    mean /= i;                    return SampleAnalysis{                        <a class="el" href="catch__amalgamated_8hpp.html#a62516a9b52be8207f277f4adc2999207">CATCH_MOVE</a>(samples),                        Estimate&lt;FDuration&gt;{ mean, mean, mean, 0.0 },                        Estimate&lt;FDuration&gt;{ FDuration( 0 ),                                             FDuration( 0 ),                                             FDuration( 0 ),                                             0.0 },                        OutlierClassification{},                        0.0                    };                }            }        } // namespace Detail    } // namespace Benchmark} // namespace Catchnamespace Catch {    namespace Benchmark {        namespace Detail {            struct do_nothing {                void operator()() const {}            };            BenchmarkFunction::callable::~callable() = default;            BenchmarkFunction::BenchmarkFunction():                f( new model&lt;do_nothing&gt;{ {} } ){}        } // namespace Detail    } // namespace Benchmark} // namespace Catch#include &lt;exception&gt;namespace Catch {    namespace Benchmark {        namespace Detail {            struct optimized_away_error : std::exception {                const char* what() const noexcept override;            };            const char* optimized_away_error::what() const noexcept {                return &quot;could not measure benchmark, maybe it was optimized away&quot;;            }            void throw_optimized_away_error() {                Catch::throw_exception(optimized_away_error{});            }        } // namespace Detail    } // namespace Benchmark} // namespace Catch// Adapted from donated nonius code.#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstddef&gt;#include &lt;numeric&gt;#include &lt;random&gt;#if defined(CATCH_CONFIG_USE_ASYNC)#include &lt;future&gt;#endifnamespace Catch {    namespace Benchmark {        namespace Detail {            namespace {                template &lt;typename URng, typename Estimator&gt;                static sample                resample( URng&amp; rng,                          unsigned int resamples,                          double const* first,                          double const* last,                          Estimator&amp; estimator ) {                    auto n = static_cast&lt;size_t&gt;( last - first );                    Catch::uniform_integer_distribution&lt;size_t&gt; dist( 0, n - 1 );                    sample out;                    out.reserve( resamples );                    std::vector&lt;double&gt; resampled;                    resampled.reserve( n );                    for ( size_t i = 0; i &lt; resamples; ++i ) {                        resampled.clear();                        for ( size_t s = 0; s &lt; n; ++s ) {                            resampled.push_back( first[dist( rng )] );                        }                        const auto estimate =                            estimator( resampled.data(), resampled.data() + resampled.size() );                        out.push_back( estimate );                    }                    std::sort( out.begin(), out.end() );                    return out;                }                static double outlier_variance( Estimate&lt;double&gt; mean,                                                Estimate&lt;double&gt; stddev,                                                int n ) {                    double sb = stddev.point;                    double mn = mean.point / n;                    double mg_min = mn / 2.;                    double sg = (std::min)( mg_min / 4., sb / std::sqrt( n ) );                    double sg2 = sg * sg;                    double sb2 = sb * sb;                    auto c_max = [n, mn, sb2, sg2]( double x ) -&gt; double {                        double k = mn - x;                        double d = k * k;                        double nd = n * d;                        double k0 = -n * nd;                        double k1 = sb2 - n * sg2 + nd;                        double det = k1 * k1 - 4 * sg2 * k0;                        return static_cast&lt;int&gt;( -2. * k0 /                                                 ( k1 + std::sqrt( det ) ) );                    };                    auto var_out = [n, sb2, sg2]( double c ) {                        double nc = n - c;                        return ( nc / n ) * ( sb2 - nc * sg2 );                    };                    return (std::min)( var_out( 1 ),                                       var_out(                                           (std::min)( c_max( 0. ),                                                       c_max( mg_min ) ) ) ) /                           sb2;                }                static double erf_inv( double x ) {                    // Code accompanying the article &quot;Approximating the erfinv</td></tr>
<tr class="separator:a49ffcf43841dcedc78c808b8e62e4f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65382d821ca7d874af23bc1cab05617" id="r_af65382d821ca7d874af23bc1cab05617"><td class="memItemLeft" align="right" valign="top"><a id="af65382d821ca7d874af23bc1cab05617" name="af65382d821ca7d874af23bc1cab05617"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CATCH2_CLANG_NO_SANITIZE_INTEGER</b></td></tr>
<tr class="separator:af65382d821ca7d874af23bc1cab05617"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af942e91344c728dbd8c9732dbf8054c9" id="r_af942e91344c728dbd8c9732dbf8054c9"><td class="memItemLeft" align="right" valign="top"><a id="af942e91344c728dbd8c9732dbf8054c9" name="af942e91344c728dbd8c9732dbf8054c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::RegistryHubSingleton</b> = Singleton&lt; RegistryHub, <a class="el" href="classCatch_1_1IRegistryHub.html">IRegistryHub</a>, <a class="el" href="classCatch_1_1IMutableRegistryHub.html">IMutableRegistryHub</a> &gt;</td></tr>
<tr class="separator:af942e91344c728dbd8c9732dbf8054c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a65dcb4c6cc6803847848523398ae680c" id="r_a65dcb4c6cc6803847848523398ae680c"><td class="memItemLeft" align="right" valign="top"><a id="a65dcb4c6cc6803847848523398ae680c" name="a65dcb4c6cc6803847848523398ae680c"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>FloatingPointKind</b> : uint8_t { <b>Float</b>
, <b>Double</b>
 }</td></tr>
<tr class="separator:a65dcb4c6cc6803847848523398ae680c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62bf6e1353fde8e95644d156c4a8b3ed" id="r_a62bf6e1353fde8e95644d156c4a8b3ed"><td class="memItemLeft" align="right" valign="top"><a id="a62bf6e1353fde8e95644d156c4a8b3ed" name="a62bf6e1353fde8e95644d156c4a8b3ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (w&lt; 6.250000)</td></tr>
<tr class="separator:a62bf6e1353fde8e95644d156c4a8b3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571030d8a3068b49d454220cfdea714f" id="r_a571030d8a3068b49d454220cfdea714f"><td class="memItemLeft" align="right" valign="top"><a id="a571030d8a3068b49d454220cfdea714f" name="a571030d8a3068b49d454220cfdea714f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::weighted_average_quantile</b> (int k, int q, double *first, double *last)</td></tr>
<tr class="separator:a571030d8a3068b49d454220cfdea714f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523468c0e7dbf99ffb1801aad78e352d" id="r_a523468c0e7dbf99ffb1801aad78e352d"><td class="memItemLeft" align="right" valign="top"><a id="a523468c0e7dbf99ffb1801aad78e352d" name="a523468c0e7dbf99ffb1801aad78e352d"></a>
<a class="el" href="structCatch_1_1Benchmark_1_1OutlierClassification.html">OutlierClassification</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::classify_outliers</b> (double const *first, double const *last)</td></tr>
<tr class="separator:a523468c0e7dbf99ffb1801aad78e352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f830d662344dd75387c26aa83e6ac3" id="r_ac5f830d662344dd75387c26aa83e6ac3"><td class="memItemLeft" align="right" valign="top"><a id="ac5f830d662344dd75387c26aa83e6ac3" name="ac5f830d662344dd75387c26aa83e6ac3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::mean</b> (double const *first, double const *last)</td></tr>
<tr class="separator:ac5f830d662344dd75387c26aa83e6ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5e70b0f758f550b2fdff85512efdb5" id="r_abc5e70b0f758f550b2fdff85512efdb5"><td class="memItemLeft" align="right" valign="top"><a id="abc5e70b0f758f550b2fdff85512efdb5" name="abc5e70b0f758f550b2fdff85512efdb5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::normal_cdf</b> (double x)</td></tr>
<tr class="separator:abc5e70b0f758f550b2fdff85512efdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d6c634e2c8901d02ffe8718817f1b4" id="r_a62d6c634e2c8901d02ffe8718817f1b4"><td class="memItemLeft" align="right" valign="top"><a id="a62d6c634e2c8901d02ffe8718817f1b4" name="a62d6c634e2c8901d02ffe8718817f1b4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::erfc_inv</b> (double x)</td></tr>
<tr class="separator:a62d6c634e2c8901d02ffe8718817f1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3527090cdeb0456b1aacbdc29050841" id="r_af3527090cdeb0456b1aacbdc29050841"><td class="memItemLeft" align="right" valign="top"><a id="af3527090cdeb0456b1aacbdc29050841" name="af3527090cdeb0456b1aacbdc29050841"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::normal_quantile</b> (double p)</td></tr>
<tr class="separator:af3527090cdeb0456b1aacbdc29050841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a635ce60c227f5217d9606e2afe527c" id="r_a0a635ce60c227f5217d9606e2afe527c"><td class="memItemLeft" align="right" valign="top"><a id="a0a635ce60c227f5217d9606e2afe527c" name="a0a635ce60c227f5217d9606e2afe527c"></a>
<a class="el" href="structCatch_1_1Benchmark_1_1Estimate.html">Estimate</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::bootstrap</b> (double confidence_level, double *first, double *last, sample const &amp;resample, double(*estimator)(double const *, double const *))</td></tr>
<tr class="separator:a0a635ce60c227f5217d9606e2afe527c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ae7ccc7fa8c996bc6e4ada5a7004b" id="r_a1a4ae7ccc7fa8c996bc6e4ada5a7004b"><td class="memItemLeft" align="right" valign="top"><a id="a1a4ae7ccc7fa8c996bc6e4ada5a7004b" name="a1a4ae7ccc7fa8c996bc6e4ada5a7004b"></a>
<a class="el" href="structCatch_1_1Benchmark_1_1Detail_1_1bootstrap__analysis.html">bootstrap_analysis</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Benchmark::Detail::analyse_samples</b> (double confidence_level, unsigned int n_resamples, double *first, double *last)</td></tr>
<tr class="separator:a1a4ae7ccc7fa8c996bc6e4ada5a7004b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af610e11bcfe94ebc07788fdcf1b716b7" id="r_af610e11bcfe94ebc07788fdcf1b716b7"><td class="memItemLeft" align="right" valign="top"><a id="af610e11bcfe94ebc07788fdcf1b716b7" name="af610e11bcfe94ebc07788fdcf1b716b7"></a>
<a class="el" href="classCatch_1_1Approx.html">Approx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::literals::operator&quot;&quot;_a</b> (long double val)</td></tr>
<tr class="separator:af610e11bcfe94ebc07788fdcf1b716b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c310bd2eaacfd7c23f7a5a1fc587bf" id="r_ad9c310bd2eaacfd7c23f7a5a1fc587bf"><td class="memItemLeft" align="right" valign="top"><a id="ad9c310bd2eaacfd7c23f7a5a1fc587bf" name="ad9c310bd2eaacfd7c23f7a5a1fc587bf"></a>
<a class="el" href="classCatch_1_1Approx.html">Approx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::literals::operator&quot;&quot;_a</b> (unsigned long long val)</td></tr>
<tr class="separator:ad9c310bd2eaacfd7c23f7a5a1fc587bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2842e594466b16b9ca13e09077b44406" id="r_a2842e594466b16b9ca13e09077b44406"><td class="memItemLeft" align="right" valign="top"><a id="a2842e594466b16b9ca13e09077b44406" name="a2842e594466b16b9ca13e09077b44406"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator==</b> (<a class="el" href="structCatch_1_1ProcessedReporterSpec.html">ProcessedReporterSpec</a> const &amp;lhs, <a class="el" href="structCatch_1_1ProcessedReporterSpec.html">ProcessedReporterSpec</a> const &amp;rhs)</td></tr>
<tr class="separator:a2842e594466b16b9ca13e09077b44406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba921d5844aa120874480fe71d1c1ae3" id="r_aba921d5844aa120874480fe71d1c1ae3"><td class="memItemLeft" align="right" valign="top"><a id="aba921d5844aa120874480fe71d1c1ae3" name="aba921d5844aa120874480fe71d1c1ae3"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::getSeed</b> ()</td></tr>
<tr class="memdesc:aba921d5844aa120874480fe71d1c1ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Catch2's current RNG seed. <br /></td></tr>
<tr class="separator:aba921d5844aa120874480fe71d1c1ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d328566cb8da87b48f1fac3f319ac7a" id="r_a5d328566cb8da87b48f1fac3f319ac7a"><td class="memItemLeft" align="right" valign="top"><a id="a5d328566cb8da87b48f1fac3f319ac7a" name="a5d328566cb8da87b48f1fac3f319ac7a"></a>
<a class="el" href="classCatch_1_1IRegistryHub.html">IRegistryHub</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::getRegistryHub</b> ()</td></tr>
<tr class="separator:a5d328566cb8da87b48f1fac3f319ac7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585459763f2c7610e57de2dd22dd1ad8" id="r_a585459763f2c7610e57de2dd22dd1ad8"><td class="memItemLeft" align="right" valign="top"><a id="a585459763f2c7610e57de2dd22dd1ad8" name="a585459763f2c7610e57de2dd22dd1ad8"></a>
<a class="el" href="classCatch_1_1IMutableRegistryHub.html">IMutableRegistryHub</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::getMutableRegistryHub</b> ()</td></tr>
<tr class="separator:a585459763f2c7610e57de2dd22dd1ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f78e9afdebc6d4512d18e76fbf54b8c" id="r_a0f78e9afdebc6d4512d18e76fbf54b8c"><td class="memItemLeft" align="right" valign="top"><a id="a0f78e9afdebc6d4512d18e76fbf54b8c" name="a0f78e9afdebc6d4512d18e76fbf54b8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::cleanUp</b> ()</td></tr>
<tr class="separator:a0f78e9afdebc6d4512d18e76fbf54b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafff91485eeeeb9e9333f317cc0e3b1" id="r_adafff91485eeeeb9e9333f317cc0e3b1"><td class="memItemLeft" align="right" valign="top"><a id="adafff91485eeeeb9e9333f317cc0e3b1" name="adafff91485eeeeb9e9333f317cc0e3b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::translateActiveException</b> ()</td></tr>
<tr class="separator:adafff91485eeeeb9e9333f317cc0e3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f033a91680546a152f5dfa4427104c" id="r_a60f033a91680546a152f5dfa4427104c"><td class="memItemLeft" align="right" valign="top"><a id="a60f033a91680546a152f5dfa4427104c" name="a60f033a91680546a152f5dfa4427104c"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::registerTranslatorImpl</b> (<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Detail::unique_ptr</a>&lt; <a class="el" href="classCatch_1_1IExceptionTranslator.html">IExceptionTranslator</a> &gt; &amp;&amp;<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">translator</a>)</td></tr>
<tr class="separator:a60f033a91680546a152f5dfa4427104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e8f5954fada348761e0473b3e4c1a2" id="r_aa7e8f5954fada348761e0473b3e4c1a2"><td class="memItemLeft" align="right" valign="top"><a id="aa7e8f5954fada348761e0473b3e4c1a2" name="aa7e8f5954fada348761e0473b3e4c1a2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="structCatch_1_1Version.html">Version</a> const &amp;version)</td></tr>
<tr class="separator:aa7e8f5954fada348761e0473b3e4c1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e54475ed669ef7f7ac00b858e91b2a" id="r_a35e54475ed669ef7f7ac00b858e91b2a"><td class="memItemLeft" align="right" valign="top"><a id="a35e54475ed669ef7f7ac00b858e91b2a" name="a35e54475ed669ef7f7ac00b858e91b2a"></a>
<a class="el" href="structCatch_1_1Version.html">Version</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::libraryVersion</b> ()</td></tr>
<tr class="separator:a35e54475ed669ef7f7ac00b858e91b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e4736f7a2b0501a13c4dc4adfe5bb6" id="r_ab6e4736f7a2b0501a13c4dc4adfe5bb6"><td class="memItemLeft" align="right" valign="top"><a id="ab6e4736f7a2b0501a13c4dc4adfe5bb6" name="ab6e4736f7a2b0501a13c4dc4adfe5bb6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Generators::Detail::throw_generator_exception</b> (char const *msg)</td></tr>
<tr class="memdesc:ab6e4736f7a2b0501a13c4dc4adfe5bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws <a class="el" href="classCatch_1_1GeneratorException.html">GeneratorException</a> with the provided message. <br /></td></tr>
<tr class="separator:ab6e4736f7a2b0501a13c4dc4adfe5bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ad55177ac1e5f00b123909b191f436" id="r_ab0ad55177ac1e5f00b123909b191f436"><td class="memItemLeft" align="right" valign="top"><a id="ab0ad55177ac1e5f00b123909b191f436" name="ab0ad55177ac1e5f00b123909b191f436"></a>
<a class="el" href="classCatch_1_1IGeneratorTracker.html">IGeneratorTracker</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Generators::acquireGeneratorTracker</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> generatorName, <a class="el" href="structCatch_1_1SourceLineInfo.html">SourceLineInfo</a> const &amp;lineInfo)</td></tr>
<tr class="separator:ab0ad55177ac1e5f00b123909b191f436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e1bac2be5e078f26c395a96470b706" id="r_a24e1bac2be5e078f26c395a96470b706"><td class="memItemLeft" align="right" valign="top"><a id="a24e1bac2be5e078f26c395a96470b706" name="a24e1bac2be5e078f26c395a96470b706"></a>
<a class="el" href="classCatch_1_1IGeneratorTracker.html">IGeneratorTracker</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Generators::createGeneratorTracker</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> generatorName, <a class="el" href="structCatch_1_1SourceLineInfo.html">SourceLineInfo</a> lineInfo, <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">GeneratorBasePtr</a> &amp;&amp;generator)</td></tr>
<tr class="separator:a24e1bac2be5e078f26c395a96470b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ff3ca07ca525084cadb89dee13e39e" id="r_a43ff3ca07ca525084cadb89dee13e39e"><td class="memItemLeft" align="right" valign="top"><a id="a43ff3ca07ca525084cadb89dee13e39e" name="a43ff3ca07ca525084cadb89dee13e39e"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Generators::Detail::getSeed</b> ()</td></tr>
<tr class="separator:a43ff3ca07ca525084cadb89dee13e39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cdeefafe46a4d606b51248eb7bbe7e" id="r_a26cdeefafe46a4d606b51248eb7bbe7e"><td class="memItemLeft" align="right" valign="top"><a id="a26cdeefafe46a4d606b51248eb7bbe7e" name="a26cdeefafe46a4d606b51248eb7bbe7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::handleExceptionMatchExpr</b> (<a class="el" href="classCatch_1_1AssertionHandler.html">AssertionHandler</a> &amp;handler, std::string const &amp;str)</td></tr>
<tr class="separator:a26cdeefafe46a4d606b51248eb7bbe7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b76a1843c33a4a71aa698a3defc528" id="r_ab5b76a1843c33a4a71aa698a3defc528"><td class="memItemLeft" align="right" valign="top"><a id="ab5b76a1843c33a4a71aa698a3defc528" name="ab5b76a1843c33a4a71aa698a3defc528"></a>
<a class="el" href="classCatch_1_1Clara_1_1Detail_1_1BasicResult.html">ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Clara::Detail::convertInto</b> (std::string const &amp;source, std::string &amp;target)</td></tr>
<tr class="separator:ab5b76a1843c33a4a71aa698a3defc528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5cc67b22b463d47af6e69ee31bf44e" id="r_aaf5cc67b22b463d47af6e69ee31bf44e"><td class="memItemLeft" align="right" valign="top"><a id="aaf5cc67b22b463d47af6e69ee31bf44e" name="aaf5cc67b22b463d47af6e69ee31bf44e"></a>
<a class="el" href="classCatch_1_1Clara_1_1Detail_1_1BasicResult.html">ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Clara::Detail::convertInto</b> (std::string const &amp;source, bool &amp;target)</td></tr>
<tr class="separator:aaf5cc67b22b463d47af6e69ee31bf44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d773398ae9697da7845bbf5027e35e" id="r_a96d773398ae9697da7845bbf5027e35e"><td class="memItemLeft" align="right" valign="top"><a id="a96d773398ae9697da7845bbf5027e35e" name="a96d773398ae9697da7845bbf5027e35e"></a>
<a class="el" href="classCatch_1_1Clara_1_1Parser.html">Clara::Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::makeCommandLineParser</b> (<a class="el" href="structCatch_1_1ConfigData.html">ConfigData</a> &amp;config)</td></tr>
<tr class="separator:a96d773398ae9697da7845bbf5027e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade51091dea188100d1c7a8acc55f5ea5" id="r_ade51091dea188100d1c7a8acc55f5ea5"><td class="memItemLeft" align="right" valign="top"><a id="ade51091dea188100d1c7a8acc55f5ea5" name="ade51091dea188100d1c7a8acc55f5ea5"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::convertToBits</b> (<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">float</a> f)</td></tr>
<tr class="separator:ade51091dea188100d1c7a8acc55f5ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cbea1ca1087603043d57005bbbec54" id="r_aa4cbea1ca1087603043d57005bbbec54"><td class="memItemLeft" align="right" valign="top"><a id="aa4cbea1ca1087603043d57005bbbec54" name="aa4cbea1ca1087603043d57005bbbec54"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::convertToBits</b> (<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">double</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">d</a>)</td></tr>
<tr class="separator:aa4cbea1ca1087603043d57005bbbec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fef8312d01399bbf5722432f099216" id="r_a18fef8312d01399bbf5722432f099216"><td class="memItemLeft" align="right" valign="top"><a id="a18fef8312d01399bbf5722432f099216" name="a18fef8312d01399bbf5722432f099216"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::directCompare</b> (<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">float</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">lhs</a>, <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">float</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">rhs</a>)</td></tr>
<tr class="separator:a18fef8312d01399bbf5722432f099216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6b189b0908b0866a4f79b5ba5f9b7d" id="r_a4e6b189b0908b0866a4f79b5ba5f9b7d"><td class="memItemLeft" align="right" valign="top"><a id="a4e6b189b0908b0866a4f79b5ba5f9b7d" name="a4e6b189b0908b0866a4f79b5ba5f9b7d"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::directCompare</b> (<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">double</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">lhs</a>, <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">double</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">rhs</a>)</td></tr>
<tr class="separator:a4e6b189b0908b0866a4f79b5ba5f9b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a53cd3f44546dfc2935a3a6d3277ce6" id="r_a9a53cd3f44546dfc2935a3a6d3277ce6"><td class="memItemLeft" align="right" valign="top"><a id="a9a53cd3f44546dfc2935a3a6d3277ce6" name="a9a53cd3f44546dfc2935a3a6d3277ce6"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">char</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">const</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::getEnv</b> (<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">char</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">const</a> *<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">varName</a>)</td></tr>
<tr class="separator:a9a53cd3f44546dfc2935a3a6d3277ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375b927ff7cc5356ff4a71626d54c83f" id="r_a375b927ff7cc5356ff4a71626d54c83f"><td class="memItemLeft" align="right" valign="top"><a id="a375b927ff7cc5356ff4a71626d54c83f" name="a375b927ff7cc5356ff4a71626d54c83f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::makeStream</b> (std::string const &amp;filename) -&gt; <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Detail::unique_ptr</a>&lt; IStream &gt;</td></tr>
<tr class="separator:a375b927ff7cc5356ff4a71626d54c83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf821d46e662c8d93d80a98d79a10314" id="r_abf821d46e662c8d93d80a98d79a10314"><td class="memItemLeft" align="right" valign="top"><a id="abf821d46e662c8d93d80a98d79a10314" name="abf821d46e662c8d93d80a98d79a10314"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="classCatch_1_1LazyExpression.html">LazyExpression</a> const &amp;lazyExpr) -&gt; std::ostream &amp;</td></tr>
<tr class="separator:abf821d46e662c8d93d80a98d79a10314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c40de0d3593160a350d9e4323311b2" id="r_a11c40de0d3593160a350d9e4323311b2"><td class="memItemLeft" align="right" valign="top"><a id="a11c40de0d3593160a350d9e4323311b2" name="a11c40de0d3593160a350d9e4323311b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::list</b> (IEventListener &amp;reporter, <a class="el" href="classCatch_1_1Config.html">Config</a> const &amp;config)</td></tr>
<tr class="separator:a11c40de0d3593160a350d9e4323311b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddf1224851353fc92bfbff6f499fa97" id="r_a0ddf1224851353fc92bfbff6f499fa97"><td class="memItemLeft" align="right" valign="top"><a id="a0ddf1224851353fc92bfbff6f499fa97" name="a0ddf1224851353fc92bfbff6f499fa97"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>main</b> (int argc, char *argv[])</td></tr>
<tr class="separator:a0ddf1224851353fc92bfbff6f499fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b1b55bbb03be501419181d88db9c6f" id="r_a73b1b55bbb03be501419181d88db9c6f"><td class="memItemLeft" align="right" valign="top"><a id="a73b1b55bbb03be501419181d88db9c6f" name="a73b1b55bbb03be501419181d88db9c6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::isRedirectAvailable</b> (OutputRedirect::Kind kind)</td></tr>
<tr class="separator:a73b1b55bbb03be501419181d88db9c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9831933e640b35f907975c129f4763f" id="r_ae9831933e640b35f907975c129f4763f"><td class="memItemLeft" align="right" valign="top"><a id="ae9831933e640b35f907975c129f4763f" name="ae9831933e640b35f907975c129f4763f"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Detail::unique_ptr</a>&lt; OutputRedirect &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::makeOutputRedirect</b> (bool actual)</td></tr>
<tr class="separator:ae9831933e640b35f907975c129f4763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6869418a3394de1080b85a72d73b37e2" id="r_a6869418a3394de1080b85a72d73b37e2"><td class="memItemLeft" align="right" valign="top"><a id="a6869418a3394de1080b85a72d73b37e2" name="a6869418a3394de1080b85a72d73b37e2"></a>
RedirectGuard&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::scopedActivate</b> (OutputRedirect &amp;redirectImpl)</td></tr>
<tr class="separator:a6869418a3394de1080b85a72d73b37e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604293e8cd25e37091594d6f30c5f54e" id="r_a604293e8cd25e37091594d6f30c5f54e"><td class="memItemLeft" align="right" valign="top"><a id="a604293e8cd25e37091594d6f30c5f54e" name="a604293e8cd25e37091594d6f30c5f54e"></a>
RedirectGuard&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::scopedDeactivate</b> (OutputRedirect &amp;redirectImpl)</td></tr>
<tr class="separator:a604293e8cd25e37091594d6f30c5f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369d3d53347e3c8da1d23ef64fa39daf" id="r_a369d3d53347e3c8da1d23ef64fa39daf"><td class="memItemLeft" align="right" valign="top"><a id="a369d3d53347e3c8da1d23ef64fa39daf" name="a369d3d53347e3c8da1d23ef64fa39daf"></a>
<a class="el" href="classCatch_1_1Optional.html">Optional</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::parseUInt</b> (std::string const &amp;input, int base)</td></tr>
<tr class="separator:a369d3d53347e3c8da1d23ef64fa39daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff37796f0f578c2816f74267e641c5f7" id="r_aff37796f0f578c2816f74267e641c5f7"><td class="memItemLeft" align="right" valign="top"><a id="aff37796f0f578c2816f74267e641c5f7" name="aff37796f0f578c2816f74267e641c5f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::isnan</b> (float f)</td></tr>
<tr class="separator:aff37796f0f578c2816f74267e641c5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d450336c237ac77721f0a3f9fb048d" id="r_a37d450336c237ac77721f0a3f9fb048d"><td class="memItemLeft" align="right" valign="top"><a id="a37d450336c237ac77721f0a3f9fb048d" name="a37d450336c237ac77721f0a3f9fb048d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::isnan</b> (double d)</td></tr>
<tr class="separator:a37d450336c237ac77721f0a3f9fb048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65d074e6c60320640a500d302b83bb2" id="r_ae65d074e6c60320640a500d302b83bb2"><td class="memItemLeft" align="right" valign="top"><a id="ae65d074e6c60320640a500d302b83bb2" name="ae65d074e6c60320640a500d302b83bb2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::nextafter</b> (float x, float y)</td></tr>
<tr class="separator:ae65d074e6c60320640a500d302b83bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add39a699bce7f13c95616fcaa62ab7ca" id="r_add39a699bce7f13c95616fcaa62ab7ca"><td class="memItemLeft" align="right" valign="top"><a id="add39a699bce7f13c95616fcaa62ab7ca" name="add39a699bce7f13c95616fcaa62ab7ca"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::nextafter</b> (double x, double y)</td></tr>
<tr class="separator:add39a699bce7f13c95616fcaa62ab7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5126d3ec2d72a47fa404b704d99010" id="r_a6d5126d3ec2d72a47fa404b704d99010"><td class="memItemLeft" align="right" valign="top"><a id="a6d5126d3ec2d72a47fa404b704d99010" name="a6d5126d3ec2d72a47fa404b704d99010"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator==</b> (<a class="el" href="classCatch_1_1SimplePcg32.html">SimplePcg32</a> const &amp;lhs, <a class="el" href="classCatch_1_1SimplePcg32.html">SimplePcg32</a> const &amp;rhs)</td></tr>
<tr class="separator:a6d5126d3ec2d72a47fa404b704d99010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a7a360e947e33298ee18f652749230" id="r_ab5a7a360e947e33298ee18f652749230"><td class="memItemLeft" align="right" valign="top"><a id="ab5a7a360e947e33298ee18f652749230" name="ab5a7a360e947e33298ee18f652749230"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator!=</b> (<a class="el" href="classCatch_1_1SimplePcg32.html">SimplePcg32</a> const &amp;lhs, <a class="el" href="classCatch_1_1SimplePcg32.html">SimplePcg32</a> const &amp;rhs)</td></tr>
<tr class="separator:ab5a7a360e947e33298ee18f652749230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170bbe5db76570c4820b5e2eb260f82b" id="r_a170bbe5db76570c4820b5e2eb260f82b"><td class="memItemLeft" align="right" valign="top"><a id="a170bbe5db76570c4820b5e2eb260f82b" name="a170bbe5db76570c4820b5e2eb260f82b"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::generateRandomSeed</b> (GenerateFrom from)</td></tr>
<tr class="separator:a170bbe5db76570c4820b5e2eb260f82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874fd7848ec5a0ef02d88c6ec37c9a03" id="r_a874fd7848ec5a0ef02d88c6ec37c9a03"><td class="memItemLeft" align="right" valign="top"><a id="a874fd7848ec5a0ef02d88c6ec37c9a03" name="a874fd7848ec5a0ef02d88c6ec37c9a03"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::splitReporterSpec</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> <a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">reporterSpec</a>)</td></tr>
<tr class="memdesc:a874fd7848ec5a0ef02d88c6ec37c9a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the reporter spec into reporter name and kv-pair options. <br /></td></tr>
<tr class="separator:a874fd7848ec5a0ef02d88c6ec37c9a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ba838a0c2e6767d095a7a01fc07b48" id="r_a64ba838a0c2e6767d095a7a01fc07b48"><td class="memItemLeft" align="right" valign="top"><a id="a64ba838a0c2e6767d095a7a01fc07b48" name="a64ba838a0c2e6767d095a7a01fc07b48"></a>
<a class="el" href="classCatch_1_1Optional.html">Optional</a>&lt; <a class="el" href="catch__amalgamated_8hpp.html#a91308e87521e370e591065a22b010025">ColourMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Detail::stringToColourMode</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> colourMode)</td></tr>
<tr class="separator:a64ba838a0c2e6767d095a7a01fc07b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408299b05a1363c7cd99fb5b6c7f1e3d" id="r_a408299b05a1363c7cd99fb5b6c7f1e3d"><td class="memItemLeft" align="right" valign="top"><a id="a408299b05a1363c7cd99fb5b6c7f1e3d" name="a408299b05a1363c7cd99fb5b6c7f1e3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator==</b> (ReporterSpec const &amp;lhs, ReporterSpec const &amp;rhs)</td></tr>
<tr class="separator:a408299b05a1363c7cd99fb5b6c7f1e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae987bd04fd59321f5183794daeffd4cf" id="r_ae987bd04fd59321f5183794daeffd4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCatch_1_1Optional.html">Optional</a>&lt; ReporterSpec &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="catch__amalgamated_8cpp.html#ae987bd04fd59321f5183794daeffd4cf">Catch::parseReporterSpec</a> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> reporterSpec)</td></tr>
<tr class="separator:ae987bd04fd59321f5183794daeffd4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718eeab870712f292ed8dc6ee3f6488" id="r_af718eeab870712f292ed8dc6ee3f6488"><td class="memItemLeft" align="right" valign="top"><a id="af718eeab870712f292ed8dc6ee3f6488" name="af718eeab870712f292ed8dc6ee3f6488"></a>
<a class="el" href="classCatch_1_1IResultCapture.html">IResultCapture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::getResultCapture</b> ()</td></tr>
<tr class="separator:af718eeab870712f292ed8dc6ee3f6488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161400810eb0995394d6d8d3cae821ad" id="r_a161400810eb0995394d6d8d3cae821ad"><td class="memItemLeft" align="right" valign="top"><a id="a161400810eb0995394d6d8d3cae821ad" name="a161400810eb0995394d6d8d3cae821ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::seedRng</b> (<a class="el" href="classCatch_1_1IConfig.html">IConfig</a> const &amp;config)</td></tr>
<tr class="separator:a161400810eb0995394d6d8d3cae821ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5ea05e942d2d7fe79111e12754ed76" id="r_acf5ea05e942d2d7fe79111e12754ed76"><td class="memItemLeft" align="right" valign="top"><a id="acf5ea05e942d2d7fe79111e12754ed76" name="acf5ea05e942d2d7fe79111e12754ed76"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::rngSeed</b> ()</td></tr>
<tr class="separator:acf5ea05e942d2d7fe79111e12754ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788ebefcd83342b7c479222a1eeffaee" id="r_a788ebefcd83342b7c479222a1eeffaee"><td class="memItemLeft" align="right" valign="top"><a id="a788ebefcd83342b7c479222a1eeffaee" name="a788ebefcd83342b7c479222a1eeffaee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::addSingleton</b> (ISingleton *singleton)</td></tr>
<tr class="separator:a788ebefcd83342b7c479222a1eeffaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdb92cb53a4e016bc0dee66efd99118" id="r_a8bdb92cb53a4e016bc0dee66efd99118"><td class="memItemLeft" align="right" valign="top"><a id="a8bdb92cb53a4e016bc0dee66efd99118" name="a8bdb92cb53a4e016bc0dee66efd99118"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::cleanupSingletons</b> ()</td></tr>
<tr class="separator:a8bdb92cb53a4e016bc0dee66efd99118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8ea1f66bc1cdc3e1254ed7fa57c06d" id="r_a8c8ea1f66bc1cdc3e1254ed7fa57c06d"><td class="memItemLeft" align="right" valign="top"><a id="a8c8ea1f66bc1cdc3e1254ed7fa57c06d" name="a8c8ea1f66bc1cdc3e1254ed7fa57c06d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="structCatch_1_1SourceLineInfo.html">SourceLineInfo</a> const &amp;info)</td></tr>
<tr class="separator:a8c8ea1f66bc1cdc3e1254ed7fa57c06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0179d453617ba2296f2baa99a49e7264" id="r_a0179d453617ba2296f2baa99a49e7264"><td class="memItemLeft" align="right" valign="top"><a id="a0179d453617ba2296f2baa99a49e7264" name="a0179d453617ba2296f2baa99a49e7264"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::cout</b> ()</td></tr>
<tr class="separator:a0179d453617ba2296f2baa99a49e7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c1ce08041448d684ae8edc14162cd2" id="r_a54c1ce08041448d684ae8edc14162cd2"><td class="memItemLeft" align="right" valign="top"><a id="a54c1ce08041448d684ae8edc14162cd2" name="a54c1ce08041448d684ae8edc14162cd2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::cerr</b> ()</td></tr>
<tr class="separator:a54c1ce08041448d684ae8edc14162cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2213f54e4d31a659db49827e81856b" id="r_a1b2213f54e4d31a659db49827e81856b"><td class="memItemLeft" align="right" valign="top"><a id="a1b2213f54e4d31a659db49827e81856b" name="a1b2213f54e4d31a659db49827e81856b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::clog</b> ()</td></tr>
<tr class="separator:a1b2213f54e4d31a659db49827e81856b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695f62327be0676e046291eeaae15110" id="r_a695f62327be0676e046291eeaae15110"><td class="memItemLeft" align="right" valign="top"><a id="a695f62327be0676e046291eeaae15110" name="a695f62327be0676e046291eeaae15110"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::startsWith</b> (std::string const &amp;s, std::string const &amp;prefix)</td></tr>
<tr class="separator:a695f62327be0676e046291eeaae15110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77a782fac38c4f6417a7af909e8b29c" id="r_aa77a782fac38c4f6417a7af909e8b29c"><td class="memItemLeft" align="right" valign="top"><a id="aa77a782fac38c4f6417a7af909e8b29c" name="aa77a782fac38c4f6417a7af909e8b29c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::startsWith</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> s, char prefix)</td></tr>
<tr class="separator:aa77a782fac38c4f6417a7af909e8b29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada025504f627feaf9ac68ca391515dff" id="r_ada025504f627feaf9ac68ca391515dff"><td class="memItemLeft" align="right" valign="top"><a id="ada025504f627feaf9ac68ca391515dff" name="ada025504f627feaf9ac68ca391515dff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::endsWith</b> (std::string const &amp;s, std::string const &amp;suffix)</td></tr>
<tr class="separator:ada025504f627feaf9ac68ca391515dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd801a3e33fd7a8b91ded0d02747a93f" id="r_afd801a3e33fd7a8b91ded0d02747a93f"><td class="memItemLeft" align="right" valign="top"><a id="afd801a3e33fd7a8b91ded0d02747a93f" name="afd801a3e33fd7a8b91ded0d02747a93f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::endsWith</b> (std::string const &amp;s, char suffix)</td></tr>
<tr class="separator:afd801a3e33fd7a8b91ded0d02747a93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52974b0e426e7e2fbd725a900e9c36e" id="r_aa52974b0e426e7e2fbd725a900e9c36e"><td class="memItemLeft" align="right" valign="top"><a id="aa52974b0e426e7e2fbd725a900e9c36e" name="aa52974b0e426e7e2fbd725a900e9c36e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::contains</b> (std::string const &amp;s, std::string const &amp;infix)</td></tr>
<tr class="separator:aa52974b0e426e7e2fbd725a900e9c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0760dbe87d090a55a35414db57d272c4" id="r_a0760dbe87d090a55a35414db57d272c4"><td class="memItemLeft" align="right" valign="top"><a id="a0760dbe87d090a55a35414db57d272c4" name="a0760dbe87d090a55a35414db57d272c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::toLowerInPlace</b> (std::string &amp;s)</td></tr>
<tr class="separator:a0760dbe87d090a55a35414db57d272c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac036a17412d318598ffda8e1fe7a1177" id="r_ac036a17412d318598ffda8e1fe7a1177"><td class="memItemLeft" align="right" valign="top"><a id="ac036a17412d318598ffda8e1fe7a1177" name="ac036a17412d318598ffda8e1fe7a1177"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::toLower</b> (std::string const &amp;s)</td></tr>
<tr class="separator:ac036a17412d318598ffda8e1fe7a1177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b13ec5c5220e066b6fe7ba7a82db9d" id="r_ad2b13ec5c5220e066b6fe7ba7a82db9d"><td class="memItemLeft" align="right" valign="top"><a id="ad2b13ec5c5220e066b6fe7ba7a82db9d" name="ad2b13ec5c5220e066b6fe7ba7a82db9d"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::toLower</b> (char c)</td></tr>
<tr class="separator:ad2b13ec5c5220e066b6fe7ba7a82db9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084108b47f37d8bfd5db51c50c7451b3" id="r_a084108b47f37d8bfd5db51c50c7451b3"><td class="memItemLeft" align="right" valign="top"><a id="a084108b47f37d8bfd5db51c50c7451b3" name="a084108b47f37d8bfd5db51c50c7451b3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::trim</b> (std::string const &amp;str)</td></tr>
<tr class="separator:a084108b47f37d8bfd5db51c50c7451b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6d8ef0349688290bd242b50a702c28" id="r_a6f6d8ef0349688290bd242b50a702c28"><td class="memItemLeft" align="right" valign="top"><a id="a6f6d8ef0349688290bd242b50a702c28" name="a6f6d8ef0349688290bd242b50a702c28"></a>
<a class="el" href="classCatch_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::trim</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> ref)</td></tr>
<tr class="separator:a6f6d8ef0349688290bd242b50a702c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4e6770da547e43e9e4eeaa05f946ea" id="r_afe4e6770da547e43e9e4eeaa05f946ea"><td class="memItemLeft" align="right" valign="top"><a id="afe4e6770da547e43e9e4eeaa05f946ea" name="afe4e6770da547e43e9e4eeaa05f946ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::replaceInPlace</b> (std::string &amp;str, std::string const &amp;replaceThis, std::string const &amp;withThis)</td></tr>
<tr class="separator:afe4e6770da547e43e9e4eeaa05f946ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678e3c779388970bb3ec5802245f93d7" id="r_a678e3c779388970bb3ec5802245f93d7"><td class="memItemLeft" align="right" valign="top"><a id="a678e3c779388970bb3ec5802245f93d7" name="a678e3c779388970bb3ec5802245f93d7"></a>
std::vector&lt; <a class="el" href="classCatch_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::splitStringRef</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> str, char delimiter)</td></tr>
<tr class="separator:a678e3c779388970bb3ec5802245f93d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d46b1ac4a1956660e4e9361c4835b8" id="r_a27d46b1ac4a1956660e4e9361c4835b8"><td class="memItemLeft" align="right" valign="top"><a id="a27d46b1ac4a1956660e4e9361c4835b8" name="a27d46b1ac4a1956660e4e9361c4835b8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator&lt;&lt;</b> (std::ostream &amp;os, pluralise const &amp;pluraliser)</td></tr>
<tr class="separator:a27d46b1ac4a1956660e4e9361c4835b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabbdedb64bd66b7e0233969f6cdfb58" id="r_acabbdedb64bd66b7e0233969f6cdfb58"><td class="memItemLeft" align="right" valign="top"><a id="acabbdedb64bd66b7e0233969f6cdfb58" name="acabbdedb64bd66b7e0233969f6cdfb58"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="classCatch_1_1StringRef.html">StringRef</a> str) -&gt; std::ostream &amp;</td></tr>
<tr class="separator:acabbdedb64bd66b7e0233969f6cdfb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae053e7e198e60bf45f2b8bc51050f5f4" id="r_ae053e7e198e60bf45f2b8bc51050f5f4"><td class="memItemLeft" align="right" valign="top"><a id="ae053e7e198e60bf45f2b8bc51050f5f4" name="ae053e7e198e60bf45f2b8bc51050f5f4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator+</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> lhs, <a class="el" href="classCatch_1_1StringRef.html">StringRef</a> rhs)</td></tr>
<tr class="separator:ae053e7e198e60bf45f2b8bc51050f5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c519834d917d9c6d2df64f26abcf059" id="r_a1c519834d917d9c6d2df64f26abcf059"><td class="memItemLeft" align="right" valign="top"><a id="a1c519834d917d9c6d2df64f26abcf059" name="a1c519834d917d9c6d2df64f26abcf059"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator+=</b> (std::string &amp;lhs, <a class="el" href="classCatch_1_1StringRef.html">StringRef</a> rhs) -&gt; std::string &amp;</td></tr>
<tr class="separator:a1c519834d917d9c6d2df64f26abcf059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dc14789e42b18c6dc26590a49a6eaa" id="r_ad9dc14789e42b18c6dc26590a49a6eaa"><td class="memItemLeft" align="right" valign="top"><a id="ad9dc14789e42b18c6dc26590a49a6eaa" name="ad9dc14789e42b18c6dc26590a49a6eaa"></a>
std::vector&lt; <a class="el" href="classCatch_1_1TestCaseHandle.html">TestCaseHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::sortTests</b> (<a class="el" href="classCatch_1_1IConfig.html">IConfig</a> const &amp;config, std::vector&lt; <a class="el" href="classCatch_1_1TestCaseHandle.html">TestCaseHandle</a> &gt; const &amp;unsortedTestCases)</td></tr>
<tr class="separator:ad9dc14789e42b18c6dc26590a49a6eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f76a88f2882e9d1d221979dec0324d" id="r_a12f76a88f2882e9d1d221979dec0324d"><td class="memItemLeft" align="right" valign="top"><a id="a12f76a88f2882e9d1d221979dec0324d" name="a12f76a88f2882e9d1d221979dec0324d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::isThrowSafe</b> (<a class="el" href="classCatch_1_1TestCaseHandle.html">TestCaseHandle</a> const &amp;testCase, <a class="el" href="classCatch_1_1IConfig.html">IConfig</a> const &amp;config)</td></tr>
<tr class="separator:a12f76a88f2882e9d1d221979dec0324d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1944a358b260e03c6695aa7ae259c9a" id="r_af1944a358b260e03c6695aa7ae259c9a"><td class="memItemLeft" align="right" valign="top"><a id="af1944a358b260e03c6695aa7ae259c9a" name="af1944a358b260e03c6695aa7ae259c9a"></a>
std::vector&lt; <a class="el" href="classCatch_1_1TestCaseHandle.html">TestCaseHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::filterTests</b> (std::vector&lt; <a class="el" href="classCatch_1_1TestCaseHandle.html">TestCaseHandle</a> &gt; const &amp;testCases, TestSpec const &amp;testSpec, <a class="el" href="classCatch_1_1IConfig.html">IConfig</a> const &amp;config)</td></tr>
<tr class="separator:af1944a358b260e03c6695aa7ae259c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7d61b3abc9c8d3c82407b380e6a414" id="r_aae7d61b3abc9c8d3c82407b380e6a414"><td class="memItemLeft" align="right" valign="top"><a id="aae7d61b3abc9c8d3c82407b380e6a414" name="aae7d61b3abc9c8d3c82407b380e6a414"></a>
std::vector&lt; <a class="el" href="classCatch_1_1TestCaseHandle.html">TestCaseHandle</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::getAllTestCasesSorted</b> (<a class="el" href="classCatch_1_1IConfig.html">IConfig</a> const &amp;config)</td></tr>
<tr class="separator:aae7d61b3abc9c8d3c82407b380e6a414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2236988eae84fb6bcc456bbf8ddfd2bf" id="r_a2236988eae84fb6bcc456bbf8ddfd2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="catch__amalgamated_8cpp.html#a2236988eae84fb6bcc456bbf8ddfd2bf">Catch::throw_test_failure_exception</a> ()</td></tr>
<tr class="separator:a2236988eae84fb6bcc456bbf8ddfd2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6db2bf035e2e570d0b6703f6f5a3d8" id="r_a7c6db2bf035e2e570d0b6703f6f5a3d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="catch__amalgamated_8cpp.html#a7c6db2bf035e2e570d0b6703f6f5a3d8">Catch::throw_test_skip_exception</a> ()</td></tr>
<tr class="separator:a7c6db2bf035e2e570d0b6703f6f5a3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4036958fd61b3ba0b3d2467e7f4f6fd7" id="r_a4036958fd61b3ba0b3d2467e7f4f6fd7"><td class="memItemLeft" align="right" valign="top"><a id="a4036958fd61b3ba0b3d2467e7f4f6fd7" name="a4036958fd61b3ba0b3d2467e7f4f6fd7"></a>
<a class="el" href="classCatch_1_1Detail_1_1unique__ptr.html">Detail::unique_ptr</a>&lt; ITestInvoker &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::makeTestInvoker</b> (void(*testAsFunction)())</td></tr>
<tr class="separator:a4036958fd61b3ba0b3d2467e7f4f6fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512213886b4304e4573b57fe42b66d4e" id="r_a512213886b4304e4573b57fe42b66d4e"><td class="memItemLeft" align="right" valign="top"><a id="a512213886b4304e4573b57fe42b66d4e" name="a512213886b4304e4573b57fe42b66d4e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator&lt;&lt;</b> (std::ostream &amp;os, Column const &amp;col)</td></tr>
<tr class="separator:a512213886b4304e4573b57fe42b66d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f631f4606e5664e764e6a6b9df5c04" id="r_a24f631f4606e5664e764e6a6b9df5c04"><td class="memItemLeft" align="right" valign="top"><a id="a24f631f4606e5664e764e6a6b9df5c04" name="a24f631f4606e5664e764e6a6b9df5c04"></a>
Column&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::Spacer</b> (size_t spaceWidth)</td></tr>
<tr class="separator:a24f631f4606e5664e764e6a6b9df5c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2627582ff1b81131b3deac691e847156" id="r_a2627582ff1b81131b3deac691e847156"><td class="memItemLeft" align="right" valign="top"><a id="a2627582ff1b81131b3deac691e847156" name="a2627582ff1b81131b3deac691e847156"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator&lt;&lt;</b> (std::ostream &amp;os, Columns const &amp;cols)</td></tr>
<tr class="separator:a2627582ff1b81131b3deac691e847156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3027b08d3fce163c060fbeb52520d28a" id="r_a3027b08d3fce163c060fbeb52520d28a"><td class="memItemLeft" align="right" valign="top"><a id="a3027b08d3fce163c060fbeb52520d28a" name="a3027b08d3fce163c060fbeb52520d28a"></a>
Columns&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator+</b> (Column const &amp;lhs, Column const &amp;rhs)</td></tr>
<tr class="separator:a3027b08d3fce163c060fbeb52520d28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe83f06ebecb334bd138dae8568ad29" id="r_a3fe83f06ebecb334bd138dae8568ad29"><td class="memItemLeft" align="right" valign="top"><a id="a3fe83f06ebecb334bd138dae8568ad29" name="a3fe83f06ebecb334bd138dae8568ad29"></a>
Columns&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator+</b> (Column &amp;&amp;lhs, Column &amp;&amp;rhs)</td></tr>
<tr class="separator:a3fe83f06ebecb334bd138dae8568ad29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12526387d93de04a83f5842cefb83d92" id="r_a12526387d93de04a83f5842cefb83d92"><td class="memItemLeft" align="right" valign="top"><a id="a12526387d93de04a83f5842cefb83d92" name="a12526387d93de04a83f5842cefb83d92"></a>
Columns &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator+=</b> (Columns &amp;lhs, Column const &amp;rhs)</td></tr>
<tr class="separator:a12526387d93de04a83f5842cefb83d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ff2aeae98d2bb38fd08399bb7da352" id="r_ae7ff2aeae98d2bb38fd08399bb7da352"><td class="memItemLeft" align="right" valign="top"><a id="ae7ff2aeae98d2bb38fd08399bb7da352" name="ae7ff2aeae98d2bb38fd08399bb7da352"></a>
Columns &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator+=</b> (Columns &amp;lhs, Column &amp;&amp;rhs)</td></tr>
<tr class="separator:ae7ff2aeae98d2bb38fd08399bb7da352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb58348d617cfd289663fe52c185e68" id="r_addb58348d617cfd289663fe52c185e68"><td class="memItemLeft" align="right" valign="top"><a id="addb58348d617cfd289663fe52c185e68" name="addb58348d617cfd289663fe52c185e68"></a>
Columns&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator+</b> (Columns const &amp;lhs, Column const &amp;rhs)</td></tr>
<tr class="separator:addb58348d617cfd289663fe52c185e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b32803ded290301e4ec200e138c541" id="r_aa8b32803ded290301e4ec200e138c541"><td class="memItemLeft" align="right" valign="top"><a id="aa8b32803ded290301e4ec200e138c541" name="aa8b32803ded290301e4ec200e138c541"></a>
Columns&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::TextFlow::operator+</b> (Columns &amp;&amp;lhs, Column &amp;&amp;rhs)</td></tr>
<tr class="separator:aa8b32803ded290301e4ec200e138c541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5a2b34a00e65b753185bbc6a4962be" id="r_a4b5a2b34a00e65b753185bbc6a4962be"><td class="memItemLeft" align="right" valign="top"><a id="a4b5a2b34a00e65b753185bbc6a4962be" name="a4b5a2b34a00e65b753185bbc6a4962be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::uncaught_exceptions</b> ()</td></tr>
<tr class="separator:a4b5a2b34a00e65b753185bbc6a4962be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64142d8bbd7638d9af0e6b6829821e86" id="r_a64142d8bbd7638d9af0e6b6829821e86"><td class="memItemLeft" align="right" valign="top"><a id="a64142d8bbd7638d9af0e6b6829821e86" name="a64142d8bbd7638d9af0e6b6829821e86"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::operator&lt;&lt;</b> (std::ostream &amp;os, XmlEncode const &amp;xmlEncode)</td></tr>
<tr class="separator:a64142d8bbd7638d9af0e6b6829821e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae345560f84f68d52fc5df4ac77eb4b92" id="r_ae345560f84f68d52fc5df4ac77eb4b92"><td class="memItemLeft" align="right" valign="top"><a id="ae345560f84f68d52fc5df4ac77eb4b92" name="ae345560f84f68d52fc5df4ac77eb4b92"></a>
IsEmptyMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::IsEmpty</b> ()</td></tr>
<tr class="separator:ae345560f84f68d52fc5df4ac77eb4b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640c1714c014191cc131b37f955f83ed" id="r_a640c1714c014191cc131b37f955f83ed"><td class="memItemLeft" align="right" valign="top"><a id="a640c1714c014191cc131b37f955f83ed" name="a640c1714c014191cc131b37f955f83ed"></a>
HasSizeMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::SizeIs</b> (std::size_t sz)</td></tr>
<tr class="separator:a640c1714c014191cc131b37f955f83ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7d45a32d4ecf1d71b24b37920a5be7" id="r_a4c7d45a32d4ecf1d71b24b37920a5be7"><td class="memItemLeft" align="right" valign="top"><a id="a4c7d45a32d4ecf1d71b24b37920a5be7" name="a4c7d45a32d4ecf1d71b24b37920a5be7"></a>
ExceptionMessageMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::Message</b> (std::string const &amp;message)</td></tr>
<tr class="separator:a4c7d45a32d4ecf1d71b24b37920a5be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88361ad809aab09ff75c87bf6cdd7fad" id="r_a88361ad809aab09ff75c87bf6cdd7fad"><td class="memItemLeft" align="right" valign="top"><a id="a88361ad809aab09ff75c87bf6cdd7fad" name="a88361ad809aab09ff75c87bf6cdd7fad"></a>
WithinUlpsMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::WithinULP</b> (double target, uint64_t maxUlpDiff)</td></tr>
<tr class="separator:a88361ad809aab09ff75c87bf6cdd7fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eb912b197be0f79e60fd1884e9ac29" id="r_af0eb912b197be0f79e60fd1884e9ac29"><td class="memItemLeft" align="right" valign="top"><a id="af0eb912b197be0f79e60fd1884e9ac29" name="af0eb912b197be0f79e60fd1884e9ac29"></a>
WithinUlpsMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::WithinULP</b> (float target, uint64_t maxUlpDiff)</td></tr>
<tr class="separator:af0eb912b197be0f79e60fd1884e9ac29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a915665906ab3efb39e118c649285f" id="r_a13a915665906ab3efb39e118c649285f"><td class="memItemLeft" align="right" valign="top"><a id="a13a915665906ab3efb39e118c649285f" name="a13a915665906ab3efb39e118c649285f"></a>
WithinAbsMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::WithinAbs</b> (double target, double margin)</td></tr>
<tr class="separator:a13a915665906ab3efb39e118c649285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dba3ba1112c48a6376a38b48ea70e2" id="r_a78dba3ba1112c48a6376a38b48ea70e2"><td class="memItemLeft" align="right" valign="top"><a id="a78dba3ba1112c48a6376a38b48ea70e2" name="a78dba3ba1112c48a6376a38b48ea70e2"></a>
WithinRelMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::WithinRel</b> (double target, double eps)</td></tr>
<tr class="separator:a78dba3ba1112c48a6376a38b48ea70e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c32f9483573cfb0d703f5f34b9848d" id="r_a01c32f9483573cfb0d703f5f34b9848d"><td class="memItemLeft" align="right" valign="top"><a id="a01c32f9483573cfb0d703f5f34b9848d" name="a01c32f9483573cfb0d703f5f34b9848d"></a>
WithinRelMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::WithinRel</b> (double target)</td></tr>
<tr class="separator:a01c32f9483573cfb0d703f5f34b9848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b303b8eb9ba612cc5c149488aa7753" id="r_a65b303b8eb9ba612cc5c149488aa7753"><td class="memItemLeft" align="right" valign="top"><a id="a65b303b8eb9ba612cc5c149488aa7753" name="a65b303b8eb9ba612cc5c149488aa7753"></a>
WithinRelMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::WithinRel</b> (float target, float eps)</td></tr>
<tr class="separator:a65b303b8eb9ba612cc5c149488aa7753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735b5278dad4189adbc79098c2360b03" id="r_a735b5278dad4189adbc79098c2360b03"><td class="memItemLeft" align="right" valign="top"><a id="a735b5278dad4189adbc79098c2360b03" name="a735b5278dad4189adbc79098c2360b03"></a>
WithinRelMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::WithinRel</b> (float target)</td></tr>
<tr class="separator:a735b5278dad4189adbc79098c2360b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d170fa146d9a4ec0d908acce010128e" id="r_a0d170fa146d9a4ec0d908acce010128e"><td class="memItemLeft" align="right" valign="top"><a id="a0d170fa146d9a4ec0d908acce010128e" name="a0d170fa146d9a4ec0d908acce010128e"></a>
IsNaNMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::IsNaN</b> ()</td></tr>
<tr class="separator:a0d170fa146d9a4ec0d908acce010128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f719bca42718f4936668308772732ae" id="r_a4f719bca42718f4936668308772732ae"><td class="memItemLeft" align="right" valign="top"><a id="a4f719bca42718f4936668308772732ae" name="a4f719bca42718f4936668308772732ae"></a>
AllTrueMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::AllTrue</b> ()</td></tr>
<tr class="separator:a4f719bca42718f4936668308772732ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072ee44afcb1647b55b6c3437f22af44" id="r_a072ee44afcb1647b55b6c3437f22af44"><td class="memItemLeft" align="right" valign="top"><a id="a072ee44afcb1647b55b6c3437f22af44" name="a072ee44afcb1647b55b6c3437f22af44"></a>
NoneTrueMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::NoneTrue</b> ()</td></tr>
<tr class="separator:a072ee44afcb1647b55b6c3437f22af44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b3d0b547a4335b786e8fcea6a11cad" id="r_a99b3d0b547a4335b786e8fcea6a11cad"><td class="memItemLeft" align="right" valign="top"><a id="a99b3d0b547a4335b786e8fcea6a11cad" name="a99b3d0b547a4335b786e8fcea6a11cad"></a>
AnyTrueMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::AnyTrue</b> ()</td></tr>
<tr class="separator:a99b3d0b547a4335b786e8fcea6a11cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae584743abef84739c036faf46eef53b7" id="r_ae584743abef84739c036faf46eef53b7"><td class="memItemLeft" align="right" valign="top"><a id="ae584743abef84739c036faf46eef53b7" name="ae584743abef84739c036faf46eef53b7"></a>
StringEqualsMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::Equals</b> (std::string const &amp;str, CaseSensitive caseSensitivity)</td></tr>
<tr class="separator:ae584743abef84739c036faf46eef53b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348b90347a2dea3747eabd01d03c114c" id="r_a348b90347a2dea3747eabd01d03c114c"><td class="memItemLeft" align="right" valign="top"><a id="a348b90347a2dea3747eabd01d03c114c" name="a348b90347a2dea3747eabd01d03c114c"></a>
StringContainsMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::ContainsSubstring</b> (std::string const &amp;str, CaseSensitive caseSensitivity)</td></tr>
<tr class="separator:a348b90347a2dea3747eabd01d03c114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b1480cb0af61579e8776cf538d0069" id="r_a12b1480cb0af61579e8776cf538d0069"><td class="memItemLeft" align="right" valign="top"><a id="a12b1480cb0af61579e8776cf538d0069" name="a12b1480cb0af61579e8776cf538d0069"></a>
EndsWithMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::EndsWith</b> (std::string const &amp;str, CaseSensitive caseSensitivity)</td></tr>
<tr class="separator:a12b1480cb0af61579e8776cf538d0069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c7edfbfb4cba59f76578304597e548" id="r_af3c7edfbfb4cba59f76578304597e548"><td class="memItemLeft" align="right" valign="top"><a id="af3c7edfbfb4cba59f76578304597e548" name="af3c7edfbfb4cba59f76578304597e548"></a>
StartsWithMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::StartsWith</b> (std::string const &amp;str, CaseSensitive caseSensitivity)</td></tr>
<tr class="separator:af3c7edfbfb4cba59f76578304597e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4de9d3e501b83d17a048cf2107629dc" id="r_af4de9d3e501b83d17a048cf2107629dc"><td class="memItemLeft" align="right" valign="top"><a id="af4de9d3e501b83d17a048cf2107629dc" name="af4de9d3e501b83d17a048cf2107629dc"></a>
RegexMatcher&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::Matches</b> (std::string const &amp;regex, CaseSensitive caseSensitivity)</td></tr>
<tr class="separator:af4de9d3e501b83d17a048cf2107629dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228a8fff5aa311bd0e3592b8cb711392" id="r_a228a8fff5aa311bd0e3592b8cb711392"><td class="memItemLeft" align="right" valign="top"><a id="a228a8fff5aa311bd0e3592b8cb711392" name="a228a8fff5aa311bd0e3592b8cb711392"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::Matchers::Detail::describe_multi_matcher</b> (<a class="el" href="classCatch_1_1StringRef.html">StringRef</a> combine, std::string const *descriptions_begin, std::string const *descriptions_end)</td></tr>
<tr class="separator:a228a8fff5aa311bd0e3592b8cb711392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c77e898254807f1a2d7195ca324c19e" id="r_a4c77e898254807f1a2d7195ca324c19e"><td class="memItemLeft" align="right" valign="top"><a id="a4c77e898254807f1a2d7195ca324c19e" name="a4c77e898254807f1a2d7195ca324c19e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Catch::handleExceptionMatchExpr</b> (<a class="el" href="classCatch_1_1AssertionHandler.html">AssertionHandler</a> &amp;handler, StringMatcher const &amp;matcher)</td></tr>
<tr class="separator:a4c77e898254807f1a2d7195ca324c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aad57484016654da87125db86f4227ea3" id="r_aad57484016654da87125db86f4227ea3"><td class="memItemLeft" align="right" valign="top"><a id="aad57484016654da87125db86f4227ea3" name="aad57484016654da87125db86f4227ea3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>w</b> = -log( ( 1.0 - x ) * ( 1.0 + x ) )</td></tr>
<tr class="separator:aad57484016654da87125db86f4227ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac483f6ce851c9ecd9fb835ff7551737c" id="r_ac483f6ce851c9ecd9fb835ff7551737c"><td class="memItemLeft" align="right" valign="top"><a id="ac483f6ce851c9ecd9fb835ff7551737c" name="ac483f6ce851c9ecd9fb835ff7551737c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>p</b> = -2.7109920616438573243e-11</td></tr>
<tr class="separator:ac483f6ce851c9ecd9fb835ff7551737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544c3fe466e421738dae463968b70ba" id="r_a0544c3fe466e421738dae463968b70ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="catch__amalgamated_8cpp.html#a0544c3fe466e421738dae463968b70ba">else</a></td></tr>
<tr class="separator:a0544c3fe466e421738dae463968b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abfb3eb1e8098e09b8a4d1fc295b265" id="r_a6abfb3eb1e8098e09b8a4d1fc295b265"><td class="memItemLeft" align="right" valign="top"><a id="a6abfb3eb1e8098e09b8a4d1fc295b265" name="a6abfb3eb1e8098e09b8a4d1fc295b265"></a>
return p *&#160;</td><td class="memItemRight" valign="bottom"><b>x</b></td></tr>
<tr class="separator:a6abfb3eb1e8098e09b8a4d1fc295b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides platform specific implementations of FatalConditionHandler</p>
<p>This means that there is a lot of conditional compilation, and platform specific code. Currently, Catch2 supports a dummy handler (if no handler is desired), and 2 platform specific handlers:</p><ul>
<li>Windows' SEH</li>
<li>POSIX signals</li>
</ul>
<p>Consequently, various pieces of code below are compiled if either of the platform specific handlers is enabled, or if none of them are enabled. It is assumed that both cannot be enabled at the same time, and doing so should cause a compilation error.</p>
<p>If another platform specific handler is added, the compile guards below will need to be updated taking these assumptions into account. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae987bd04fd59321f5183794daeffd4cf" name="ae987bd04fd59321f5183794daeffd4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae987bd04fd59321f5183794daeffd4cf">&#9670;&#160;</a></span>parseReporterSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Optional&lt; ReporterSpec &gt; Catch::parseReporterSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCatch_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>reporterSpec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses provided reporter spec string into</p>
<p>Returns empty optional on errors, e.g.</p><ul>
<li>field that is not first and not a key+value pair</li>
<li>duplicated keys in kv pair</li>
<li>unknown catch reporter option</li>
<li>empty key/value in an custom kv pair</li>
<li>... </li>
</ul>

</div>
</div>
<a id="a2236988eae84fb6bcc456bbf8ddfd2bf" name="a2236988eae84fb6bcc456bbf8ddfd2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2236988eae84fb6bcc456bbf8ddfd2bf">&#9670;&#160;</a></span>throw_test_failure_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Catch::throw_test_failure_exception </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines throwing of <code>TestFailureException</code> into a single TU</p>
<p>Also handles <code>CATCH_CONFIG_DISABLE_EXCEPTIONS</code> for callers. </p>

</div>
</div>
<a id="a7c6db2bf035e2e570d0b6703f6f5a3d8" name="a7c6db2bf035e2e570d0b6703f6f5a3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6db2bf035e2e570d0b6703f6f5a3d8">&#9670;&#160;</a></span>throw_test_skip_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Catch::throw_test_skip_exception </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines throwing of <code>TestSkipException</code> into a single TU</p>
<p>Also handles <code>CATCH_CONFIG_DISABLE_EXCEPTIONS</code> for callers. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0544c3fe466e421738dae463968b70ba" name="a0544c3fe466e421738dae463968b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544c3fe466e421738dae463968b70ba">&#9670;&#160;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">                        w = sqrt( w ) - 5.000000</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
